[
  {
    "id": 1,
    "title": "Hello World",
    "slug": "hello-world",
    "categoryId": 1,
    "description": "Our first program will print the classic \"hello world\" message.",
    "code": "print(\"hello world\")",
    "explanation": "To run the program, put the code in hello-world.py and use python.",
    "output": "hello world",
    "order": 1
  },
  {
    "id": 2,
    "title": "Literals",
    "slug": "literals",
    "categoryId": 1,
    "description": "Python has various value types including strings, integers, floats, booleans, etc.",
    "code": "print(\"python\" + \"rocks\")\nprint(\"1+1 =\", 1+1)\nprint(\"7.0/3.0 =\", 7.0/3.0)\nprint(True and False)\nprint(True or False)\nprint(not True)",
    "explanation": "Strings can be concatenated with +. Numbers support arithmetic operations. Booleans work with logical operators.",
    "output": "pythonrocks\n1+1 = 2\n7.0/3.0 = 2.3333333333333335\nFalse\nTrue\nFalse",
    "order": 2
  },
  {
    "id": 3,
    "title": "Variables",
    "slug": "variables",
    "categoryId": 1,
    "description": "In Python, variables are declared and assigned with =.",
    "code": "a = \"initial\"\nprint(a)\n\nb = 1\nc = 2\nprint(b, c)\n\nd = True\nprint(d)",
    "explanation": "Python uses dynamic typing - you don't need to declare variable types explicitly.",
    "output": "initial\n1 2\nTrue",
    "order": 3
  },
  {
    "id": 4,
    "title": "Constants",
    "slug": "constants",
    "categoryId": 1,
    "description": "Python supports constants by convention using UPPERCASE names.",
    "code": "PI = 3.14159\nMAX_SIZE = 100\nprint(\"PI:\", PI)\nprint(\"MAX_SIZE:\", MAX_SIZE)",
    "explanation": "Python doesn't have built-in constants. By convention, variables in ALL_CAPS are treated as constants.",
    "output": "PI: 3.14159\nMAX_SIZE: 100",
    "order": 4
  },
  {
    "id": 5,
    "title": "For Loops",
    "slug": "for-loops",
    "categoryId": 1,
    "description": "for is Python's primary looping construct.",
    "code": "for j in range(1, 4):\n    print(j)\n\nfor i in range(10):\n    if i >= 2:\n        break\n    print(\"loop\")\n\nfor n in range(6):\n    if n % 2 == 0:\n        continue\n    print(n)",
    "explanation": "Python's for loop iterates over sequences. break exits the loop, continue skips to the next iteration.",
    "output": "1\n2\n3\nloop\nloop\n1\n3\n5",
    "order": 5
  },
  {
    "id": 6,
    "title": "If / Else",
    "slug": "if-else",
    "categoryId": 1,
    "description": "Branching with if and else in Python is straightforward.",
    "code": "if 7 % 2 == 0:\n    print(\"7 is even\")\nelse:\n    print(\"7 is odd\")\n\nif 8 % 4 == 0:\n    print(\"8 is divisible by 4\")\n\nnum = 9\nprint(\"9 is odd\" if num % 2 == 1 else \"9 is even\")",
    "explanation": "Python uses if, elif, and else for conditional statements. The ternary operator provides concise conditionals.",
    "output": "7 is odd\n8 is divisible by 4\n9 is odd",
    "order": 6
  },
  {
    "id": 7,
    "title": "Pattern Matching",
    "slug": "pattern-matching",
    "categoryId": 1,
    "description": "Python 3.10+ supports pattern matching with match/case statements.",
    "code": "def describe_animal(animal):\n    match animal:\n        case \"dog\":\n            return \"loyal companion\"\n        case \"cat\":\n            return \"independent hunter\"\n        case _:\n            return \"unknown animal\"\n\nprint(describe_animal(\"dog\"))\nprint(describe_animal(\"fish\"))",
    "explanation": "Pattern matching with match/case statements was introduced in Python 3.10. The underscore (_) acts as a wildcard.",
    "output": "loyal companion\nunknown animal",
    "order": 7
  },
  {
    "id": 8,
    "title": "Lists",
    "slug": "lists",
    "categoryId": 1,
    "description": "Lists are Python's basic sequence type.",
    "code": "s = []\nprint(\"emp:\", s)\n\ns = [\"a\", \"b\", \"c\"]\nprint(\"set:\", s)\nprint(\"get:\", s[2])\nprint(\"len:\", len(s))\n\ns.append(\"d\")\nprint(\"apd:\", s)\n\nc = s.copy()\nprint(\"cpy:\", c)\n\nl = s[2:5]\nprint(\"sl1:\", l)",
    "explanation": "Lists in Python are ordered, mutable sequences that can hold items of any type.",
    "output": "emp: []\nset: ['a', 'b', 'c']\nget: c\nlen: 3\napd: ['a', 'b', 'c', 'd']\ncpy: ['a', 'b', 'c', 'd']\nsl1: ['c', 'd']",
    "order": 8
  },
  {
    "id": 9,
    "title": "Tuples",
    "slug": "tuples",
    "categoryId": 1,
    "description": "Tuples are immutable sequences.",
    "code": "a = (\"apple\", \"banana\")\nprint(a)\nprint(\"First:\", a[0])\nprint(\"Length:\", len(a))\n\nfruit1, fruit2 = a\nprint(\"Unpacked:\", fruit1, fruit2)",
    "explanation": "Tuples are ordered, immutable sequences. Tuple unpacking allows assigning multiple variables at once.",
    "output": "('apple', 'banana')\nFirst: apple\nLength: 2\nUnpacked: apple banana",
    "order": 9
  },
  {
    "id": 10,
    "title": "List Slicing",
    "slug": "list-slicing",
    "categoryId": 1,
    "description": "Slicing allows extracting portions of lists using [start:stop:step] syntax.",
    "code": "numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(\"Original:\", numbers)\nprint(\"[2:5]:\", numbers[2:5])\nprint(\"[:4]:\", numbers[:4])\nprint(\"[6:]:\", numbers[6:])\nprint(\"[::-1]:\", numbers[::-1])",
    "explanation": "Slicing extracts subsequences from lists. The syntax is [start:stop:step].",
    "output": "Original: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[2:5]: [2, 3, 4]\n[:4]: [0, 1, 2, 3]\n[6:]: [6, 7, 8, 9]\n[::-1]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]",
    "order": 10
  },
  {
    "id": 11,
    "title": "Dictionaries",
    "slug": "dictionaries",
    "categoryId": 1,
    "description": "Dictionaries are Python's built-in mapping type.",
    "code": "m = {}\nm[\"k1\"] = 7\nm[\"k2\"] = 13\nprint(\"map:\", m)\nprint(\"len:\", len(m))\n\nv1 = m[\"k1\"]\nprint(\"v1:\", v1)\n\ndel m[\"k2\"]\nprint(\"map:\", m)\n\nn = {\"foo\": 1, \"bar\": 2}\nprint(\"map:\", n)",
    "explanation": "Dictionaries store key-value pairs. Use square brackets to access values.",
    "output": "map: {'k1': 7, 'k2': 13}\nlen: 2\nv1: 7\nmap: {'k1': 7}\nmap: {'foo': 1, 'bar': 2}",
    "order": 11
  },
  {
    "id": 12,
    "title": "Functions",
    "slug": "functions",
    "categoryId": 1,
    "description": "Functions are central in Python.",
    "code": "def plus(a, b):\n    return a + b\n\nres = plus(1, 2)\nprint(\"1+2 =\", res)\n\ndef greet(name, greeting=\"Hello\"):\n    return f\"{greeting}, {name}!\"\n\nprint(greet(\"Alice\"))\nprint(greet(\"Bob\", \"Hi\"))",
    "explanation": "Functions in Python are defined with def. They can have default parameter values.",
    "output": "1+2 = 3\nHello, Alice!\nHi, Bob!",
    "order": 12
  },
  {
    "id": 13,
    "title": "Multiple Return Values",
    "slug": "multiple-return-values",
    "categoryId": 1,
    "description": "Python supports multiple return values via tuples.",
    "code": "def vals():\n    return 3, 7\n\na, b = vals()\nprint(a)\nprint(b)\n\n_, c = vals()\nprint(\"Only second value:\", c)",
    "explanation": "Python's tuple unpacking makes it easy to return and handle multiple values from functions.",
    "output": "3\n7\nOnly second value: 7",
    "order": 13
  },
  {
    "id": 14,
    "title": "Variadic Functions",
    "slug": "variadic-functions",
    "categoryId": 1,
    "description": "Variadic functions can be called with any number of trailing arguments.",
    "code": "def sum_numbers(*nums):\n    total = 0\n    for num in nums:\n        total += num\n    return total\n\nresult = sum_numbers(1, 2)\nprint(\"Sum:\", result)\n\nnums = [1, 2, 3, 4]\nresult = sum_numbers(*nums)\nprint(\"Sum of list:\", result)",
    "explanation": "Use *args to accept any number of positional arguments. The * operator can unpack sequences when calling functions.",
    "output": "Sum: 3\nSum of list: 10",
    "order": 14
  },
  {
    "id": 15,
    "title": "Closures",
    "slug": "closures",
    "categoryId": 1,
    "description": "Python supports closures.",
    "code": "def int_seq():\n    i = 0\n    def next_val():\n        nonlocal i\n        i += 1\n        return i\n    return next_val\n\nnext_int = int_seq()\nprint(next_int())\nprint(next_int())\nprint(next_int())",
    "explanation": "Closures allow inner functions to access variables from their outer scope.",
    "output": "1\n2\n3",
    "order": 15
  },
  {
    "id": 16,
    "title": "Recursion",
    "slug": "recursion",
    "categoryId": 1,
    "description": "Python supports recursive functions.",
    "code": "def fact(n):\n    if n == 0:\n        return 1\n    return n * fact(n-1)\n\nprint(\"7! =\", fact(7))\n\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\nprint(\"fib(7) =\", fib(7))",
    "explanation": "Recursive functions call themselves. Base cases prevent infinite recursion.",
    "output": "7! = 5040\nfib(7) = 13",
    "order": 16
  },
  {
    "id": 17,
    "title": "Iteration",
    "slug": "iteration",
    "categoryId": 1,
    "description": "Python's for loops can iterate over various built-in types.",
    "code": "nums = [2, 3, 4]\nsum_val = 0\nfor num in nums:\n    sum_val += num\nprint(\"sum:\", sum_val)\n\nfor i, num in enumerate(nums):\n    if num == 3:\n        print(\"index:\", i)\n\nkvs = {\"a\": \"apple\", \"b\": \"banana\"}\nfor k, v in kvs.items():\n    print(f\"{k} -> {v}\")",
    "explanation": "Python's for loop works with any iterable. Use enumerate() to get indices, items() for dictionary iteration.",
    "output": "sum: 9\nindex: 1\na -> apple\nb -> banana",
    "order": 17
  },
  {
    "id": 18,
    "title": "References",
    "slug": "references",
    "categoryId": 1,
    "description": "Python uses object references.",
    "code": "def zero_val(ival):\n    ival = 0\n\ndef zero_ptr(iptr):\n    iptr[0] = 0\n\ni = 1\nprint(\"initial:\", i)\nzero_val(i)\nprint(\"zero_val:\", i)\n\niptr = [1]\nprint(\"initial:\", iptr[0])\nzero_ptr(iptr)\nprint(\"zero_ptr:\", iptr[0])",
    "explanation": "Python passes object references. Immutable objects can't be modified, but mutable objects can be.",
    "output": "initial: 1\nzero_val: 1\ninitial: 1\nzero_ptr: 0",
    "order": 18
  },
  {
    "id": 19,
    "title": "Strings and Unicode",
    "slug": "strings-unicode",
    "categoryId": 1,
    "description": "Python strings are Unicode by default.",
    "code": "s = \"hello\"\nprint(\"Length:\", len(s))\nprint(\"Char at 1:\", s[1])\n\nprint(\"Substring:\", s[1:3])\nprint(\"Contains 'll':\", \"ll\" in s)\nprint(\"Count 'l':\", s.count(\"l\"))\nprint(\"Replace:\", s.replace(\"l\", \"L\"))\n\nunicode_str = \"Hello, 世界\"\nprint(\"Unicode:\", unicode_str)\nprint(\"Length:\", len(unicode_str))",
    "explanation": "Python 3 strings are Unicode by default. They support slicing, searching, and various string methods.",
    "output": "Length: 5\nChar at 1: e\nSubstring: el\nContains 'll': True\nCount 'l': 2\nReplace: heLLo\nUnicode: Hello, 世界\nLength: 9",
    "order": 19
  },
  {
    "id": 20,
    "title": "Classes",
    "slug": "classes",
    "categoryId": 1,
    "description": "Python supports classes and objects.",
    "code": "class Person:\n    def __init__(self, name):\n        self.name = name\n    \n    def greet(self):\n        return f\"Hello, I'm {self.name}\"\n\np = Person(\"Alice\")\nprint(p.greet())\nprint(\"Name:\", p.name)\n\np.name = \"Bob\"\nprint(p.greet())",
    "explanation": "Classes define object types. __init__ is the constructor. Methods take self as the first parameter.",
    "output": "Hello, I'm Alice\nName: Alice\nHello, I'm Bob",
    "order": 20
  },
  {
    "id": 21,
    "title": "Methods",
    "slug": "methods",
    "categoryId": 1,
    "description": "Python methods are functions associated with a type.",
    "code": "class Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)\n\nr = Rectangle(10, 5)\nprint(\"Area:\", r.area())\nprint(\"Perimeter:\", r.perimeter())",
    "explanation": "Methods are functions defined inside a class. They operate on the object's data.",
    "output": "Area: 50\nPerimeter: 30",
    "order": 21
  },
  {
    "id": 22,
    "title": "Duck Typing",
    "slug": "duck-typing",
    "categoryId": 1,
    "description": "Python uses duck typing - if it walks like a duck and quacks like a duck, it's a duck.",
    "code": "class Duck:\n    def quack(self):\n        return \"Quack!\"\n\nclass Dog:\n    def quack(self):\n        return \"Woof!\"\n\ndef make_it_quack(animal):\n    return animal.quack()\n\nduck = Duck()\ndog = Dog()\n\nprint(make_it_quack(duck))\nprint(make_it_quack(dog))",
    "explanation": "Duck typing means that the type or class of an object is less important than the methods it defines.",
    "output": "Quack!\nWoof!",
    "order": 22
  },
  {
    "id": 23,
    "title": "Enums",
    "slug": "enums",
    "categoryId": 1,
    "description": "Python supports enumerations via the enum module.",
    "code": "from enum import Enum\n\nclass Direction(Enum):\n    NORTH = 1\n    SOUTH = 2\n    EAST = 3\n    WEST = 4\n\nprint(Direction.NORTH)\nprint(Direction.NORTH.name)\nprint(Direction.NORTH.value)\n\nfor direction in Direction:\n    print(direction)",
    "explanation": "Enums provide a way to create named constants. Each enum member has a name and a value.",
    "output": "Direction.NORTH\nNORTH\n1\nDirection.NORTH\nDirection.SOUTH\nDirection.EAST\nDirection.WEST",
    "order": 23
  },
  {
    "id": 24,
    "title": "Inheritance",
    "slug": "inheritance",
    "categoryId": 1,
    "description": "Python supports inheritance and composition.",
    "code": "class Animal:\n    def __init__(self, name):\n        self.name = name\n    \n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return f\"{self.name} barks\"\n\nclass Cat(Animal):\n    def speak(self):\n        return f\"{self.name} meows\"\n\ndog = Dog(\"Buddy\")\ncat = Cat(\"Whiskers\")\n\nprint(dog.speak())\nprint(cat.speak())",
    "explanation": "Inheritance allows classes to inherit methods and attributes from parent classes.",
    "output": "Buddy barks\nWhiskers meows",
    "order": 24
  },
  {
    "id": 25,
    "title": "Generics",
    "slug": "generics",
    "categoryId": 1,
    "description": "Python supports generic types through type hints.",
    "code": "from typing import TypeVar, Generic, List\n\nT = TypeVar('T')\n\nclass Stack(Generic[T]):\n    def __init__(self) -> None:\n        self._items: List[T] = []\n    \n    def push(self, item: T) -> None:\n        self._items.append(item)\n    \n    def pop(self) -> T:\n        return self._items.pop()\n\nint_stack = Stack[int]()\nint_stack.push(1)\nint_stack.push(2)\nprint(int_stack.pop())",
    "explanation": "Generics allow you to write code that works with multiple types while maintaining type safety.",
    "output": "2",
    "order": 25
  },
  {
    "id": 26,
    "title": "Iterators",
    "slug": "iterators",
    "categoryId": 1,
    "description": "Iterators implement the iterator protocol with __iter__ and __next__.",
    "code": "class Counter:\n    def __init__(self, start, end):\n        self.current = start\n        self.end = end\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self.current < self.end:\n            num = self.current\n            self.current += 1\n            return num\n        else:\n            raise StopIteration\n\ncounter = Counter(1, 4)\nfor num in counter:\n    print(num)",
    "explanation": "Iterators are objects that implement __iter__ and __next__ methods for iteration protocol.",
    "output": "1\n2\n3",
    "order": 26
  },
  {
    "id": 27,
    "title": "Exceptions",
    "slug": "exceptions",
    "categoryId": 1,
    "description": "Python uses exceptions for error handling.",
    "code": "def may_panic():\n    raise Exception(\"a problem\")\n\ntry:\n    may_panic()\nexcept Exception as e:\n    print(\"Caught exception:\", e)\n\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\nfinally:\n    print(\"Always executed\")",
    "explanation": "Use try/except to handle exceptions. finally blocks always execute regardless of exceptions.",
    "output": "Caught exception: a problem\nCannot divide by zero\nAlways executed",
    "order": 27
  },
  {
    "id": 28,
    "title": "Custom Exceptions",
    "slug": "custom-exceptions",
    "categoryId": 1,
    "description": "You can create custom exception types.",
    "code": "class MyError(Exception):\n    def __init__(self, message, code):\n        super().__init__(message)\n        self.code = code\n\ndef risky_function():\n    raise MyError(\"Something went wrong\", 42)\n\ntry:\n    risky_function()\nexcept MyError as e:\n    print(f\"Custom error: {e}\")\n    print(f\"Error code: {e.code}\")",
    "explanation": "Custom exceptions inherit from Exception. They can carry additional data beyond the error message.",
    "output": "Custom error: Something went wrong\nError code: 42",
    "order": 28
  },
  {
    "id": 29,
    "title": "Threads",
    "slug": "threads",
    "categoryId": 1,
    "description": "Python supports threading for concurrent execution.",
    "code": "import threading\nimport time\n\ndef worker(name):\n    for i in range(3):\n        print(f\"Worker {name}: {i}\")\n        time.sleep(0.1)\n\nthread1 = threading.Thread(target=worker, args=(\"A\",))\nthread2 = threading.Thread(target=worker, args=(\"B\",))\n\nthread1.start()\nthread2.start()\n\nthread1.join()\nthread2.join()\n\nprint(\"All threads finished\")",
    "explanation": "Threading allows concurrent execution. Use join() to wait for threads to complete.",
    "output": "Worker A: 0\nWorker B: 0\nWorker A: 1\nWorker B: 1\nWorker A: 2\nWorker B: 2\nAll threads finished",
    "order": 29
  },
  {
    "id": 30,
    "title": "Coroutines",
    "slug": "coroutines",
    "categoryId": 1,
    "description": "Python supports coroutines with async/await.",
    "code": "import asyncio\n\nasync def say_hello(name, delay):\n    await asyncio.sleep(delay)\n    print(f\"Hello, {name}!\")\n\nasync def main():\n    await asyncio.gather(\n        say_hello(\"Alice\", 1),\n        say_hello(\"Bob\", 0.5),\n        say_hello(\"Charlie\", 1.5)\n    )\n    print(\"All coroutines finished\")\n\n# In a real script: asyncio.run(main())\nprint(\"Async example (would run concurrently)\")",
    "explanation": "Coroutines enable asynchronous programming. Use async def to define coroutines and await to call them.",
    "output": "Async example (would run concurrently)",
    "order": 30
  }
]