[
  {
    "id": 1,
    "title": "Hello World",
    "slug": "hello-world",
    "description": "Our first program will print the classic \"hello world\" message.",
    "code": "#!/usr/bin/env python3\n# hello-world.py\n# This is our first Python program\n\n# Print a simple greeting message\nprint(\"hello world\")\n\n# You can also print multiple things\nprint(\"Welcome to\", \"Python!\")\n\n# Print with different separators\nprint(\"Python\", \"is\", \"awesome\", sep=\"-\")\n\n# Print with custom end character\nprint(\"Learning Python\", end=\"!\\n\")",
    "explanation": "Python's print() function is the most basic way to output text. You can print strings, multiple values separated by commas, and customize the separator and ending characters.",
    "output": "$ python hello-world.py\nhello world\nWelcome to Python!\nPython-is-awesome\nLearning Python!",
    "order": 1
  },
  {
    "id": 2,
    "title": "Literals",
    "slug": "literals",
    "description": "Python has various value types including strings, integers, floats, booleans, etc.",
    "code": "#!/usr/bin/env python3\n# literals.py\n# Demonstrating different types of literals in Python\n\n# String literals and operations\nprint(\"=== String Literals ===\")\nprint(\"python\" + \"rocks\")  # Concatenation\nprint(\"Hello\", \"World\")    # Comma-separated printing\nprint(f\"Formatted: {'Python'} version {3.9}\")  # f-strings\nprint(\"Multi-line\\nstring with\\nline breaks\")\nprint(r\"Raw string: \\n doesn't create newline\")\n\n# Numeric literals and arithmetic\nprint(\"\\n=== Numeric Literals ===\")\nprint(f\"Integer: {42}\")\nprint(f\"Float: {3.14159}\")\nprint(f\"Scientific notation: {1.23e-4}\")\nprint(f\"Binary: {0b1010} (decimal: {0b1010})\")\nprint(f\"Hex: {0xFF} (decimal: {0xFF})\")\nprint(f\"Octal: {0o755} (decimal: {0o755})\")\n\n# Arithmetic operations\nprint(\"\\n=== Arithmetic Operations ===\")\nprint(f\"1+1 = {1+1}\")\nprint(f\"7.0/3.0 = {7.0/3.0}\")\nprint(f\"10//3 = {10//3}\")  # Floor division\nprint(f\"10%3 = {10%3}\")   # Modulo\nprint(f\"2**8 = {2**8}\")   # Exponentiation\n\n# Boolean literals and operations\nprint(\"\\n=== Boolean Literals ===\")\nprint(f\"True and False: {True and False}\")\nprint(f\"True or False: {True or False}\")\nprint(f\"not True: {not True}\")\nprint(f\"bool(0): {bool(0)}\")\nprint(f\"bool('hello'): {bool('hello')}\")\n\n# Special literals\nprint(\"\\n=== Special Literals ===\")\nprint(f\"None value: {None}\")\nprint(f\"Empty list: {[]}\")\nprint(f\"Empty dict: {{}}\")",
    "explanation": "Python supports rich literal types including strings (with f-strings, raw strings), numbers (integers, floats, scientific notation, different bases), booleans, and special values like None. Each type has specific operations and behaviors.",
    "output": "$ python literals.py\n=== String Literals ===\npythonrocks\nHello World\nFormatted: Python version 3.9\nMulti-line\nstring with\nline breaks\nRaw string: \\n doesn't create newline\n\n=== Numeric Literals ===\nInteger: 42\nFloat: 3.14159\nScientific notation: 0.000123\nBinary: 10 (decimal: 10)\nHex: 255 (decimal: 255)\nOctal: 493 (decimal: 493)\n\n=== Arithmetic Operations ===\n1+1 = 2\n7.0/3.0 = 2.3333333333333335\n10//3 = 3\n10%3 = 1\n2**8 = 256\n\n=== Boolean Literals ===\nTrue and False: False\nTrue or False: True\nnot True: False\nbool(0): False\nbool('hello'): True\n\n=== Special Literals ===\nNone value: None\nEmpty list: []\nEmpty dict: {}",
    "order": 2
  },
  {
    "id": 3,
    "title": "Variables",
    "slug": "variables",
    "description": "In Python, variables are declared and assigned with =.",
    "code": "#!/usr/bin/env python3\n# variables.py\n# Demonstrating variable assignment and types\n\n# String variable\na = \"initial\"\nprint(f\"String variable a: {a}\")\n\n# Multiple assignment\nb = 1\nc = 2\nprint(f\"Numbers b and c: {b}, {c}\")\n\n# Python is dynamically typed\nd = True\nprint(f\"Boolean d: {d}\")\n\n# Variables can change type\nvalue = 42        # integer\nprint(f\"value as int: {value}\")\nvalue = \"hello\"   # now string\nprint(f\"value as string: {value}\")\nvalue = 3.14      # now float\nprint(f\"value as float: {value}\")\n\n# Multiple assignment in one line\nx, y, z = 1, 2, 3\nprint(f\"Multiple assignment: x={x}, y={y}, z={z}\")",
    "explanation": "Python uses dynamic typing - you don't need to declare variable types explicitly. Variables can change types during runtime, and you can assign multiple variables at once.",
    "output": "$ python variables.py\nString variable a: initial\nNumbers b and c: 1, 2\nBoolean d: True\nvalue as int: 42\nvalue as string: hello\nvalue as float: 3.14\nMultiple assignment: x=1, y=2, z=3",
    "order": 3
  },
  {
    "id": 4,
    "title": "Constants",
    "slug": "constants",
    "description": "Python supports constants by convention using UPPERCASE names.",
    "code": "PI = 3.14159\nMAX_SIZE = 100\nprint(\"PI:\", PI)\nprint(\"MAX_SIZE:\", MAX_SIZE)",
    "explanation": "Python doesn't have built-in constants. By convention, variables in ALL_CAPS are treated as constants.",
    "output": "PI: 3.14159\nMAX_SIZE: 100",
    "order": 4
  },
  {
    "id": 5,
    "title": "For Loops",
    "slug": "for-loops",
    "description": "for is Python's primary looping construct.",
    "code": "#!/usr/bin/env python3\n# for-loops.py\n# Demonstrating different types of for loops\n\n# Basic range loop\nprint(\"Basic range(1, 4):\")\nfor j in range(1, 4):\n    print(f\"  j = {j}\")\n\n# Loop with break\nprint(\"\\nLoop with break:\")\nfor i in range(10):\n    if i >= 2:\n        print(f\"  Breaking at i = {i}\")\n        break\n    print(f\"  loop iteration {i}\")\n\n# Loop with continue\nprint(\"\\nLoop with continue (odd numbers only):\")\nfor n in range(6):\n    if n % 2 == 0:  # skip even numbers\n        continue\n    print(f\"  odd number: {n}\")\n\n# Looping over a list\nprint(\"\\nLooping over a list:\")\nfruits = [\"apple\", \"banana\", \"cherry\"]\nfor fruit in fruits:\n    print(f\"  I like {fruit}\")\n\n# Loop with enumerate for index\nprint(\"\\nLoop with enumerate:\")\nfor index, fruit in enumerate(fruits):\n    print(f\"  {index}: {fruit}\")",
    "explanation": "Python's for loop iterates over sequences. range() generates number sequences. break exits the loop, continue skips to the next iteration. enumerate() provides both index and value when looping.",
    "output": "$ python for-loops.py\nBasic range(1, 4):\n  j = 1\n  j = 2\n  j = 3\n\nLoop with break:\n  loop iteration 0\n  loop iteration 1\n  Breaking at i = 2\n\nLoop with continue (odd numbers only):\n  odd number: 1\n  odd number: 3\n  odd number: 5\n\nLooping over a list:\n  I like apple\n  I like banana\n  I like cherry\n\nLoop with enumerate:\n  0: apple\n  1: banana\n  2: cherry",
    "order": 5
  },
  {
    "id": 6,
    "title": "If / Else",
    "slug": "if-else",
    "description": "Branching with if and else in Python is straightforward.",
    "code": "if 7 % 2 == 0:\n    print(\"7 is even\")\nelse:\n    print(\"7 is odd\")\n\nif 8 % 4 == 0:\n    print(\"8 is divisible by 4\")\n\nnum = 9\nprint(\"9 is odd\" if num % 2 == 1 else \"9 is even\")",
    "explanation": "Python uses if, elif, and else for conditional statements. The ternary operator provides concise conditionals.",
    "output": "7 is odd\n8 is divisible by 4\n9 is odd",
    "order": 6
  },
  {
    "id": 7,
    "title": "Pattern Matching",
    "slug": "pattern-matching",
    "description": "Python 3.10+ supports pattern matching with match/case statements.",
    "code": "def describe_animal(animal):\n    match animal:\n        case \"dog\":\n            return \"loyal companion\"\n        case \"cat\":\n            return \"independent hunter\"\n        case _:\n            return \"unknown animal\"\n\nprint(describe_animal(\"dog\"))\nprint(describe_animal(\"fish\"))",
    "explanation": "Pattern matching with match/case statements was introduced in Python 3.10. The underscore (_) acts as a wildcard.",
    "output": "loyal companion\nunknown animal",
    "order": 7
  },
  {
    "id": 8,
    "title": "Lists",
    "slug": "lists",
    "description": "Lists are Python's basic sequence type.",
    "code": "# Creating and working with lists\nmy_list = []\nprint(\"Empty list:\", my_list)\n\n# List with initial values\nfruits = [\"apple\", \"banana\", \"cherry\"]\nprint(\"Fruits:\", fruits)\nprint(\"First fruit:\", fruits[0])\nprint(\"Last fruit:\", fruits[-1])  # Negative indexing\nprint(\"Length:\", len(fruits))\n\n# Adding elements\nfruits.append(\"date\")\nfruits.insert(1, \"blueberry\")  # Insert at index 1\nprint(\"After adding:\", fruits)\n\n# List slicing\nprint(\"First two:\", fruits[:2])\nprint(\"Last two:\", fruits[-2:])\n\n# List comprehension\nsquares = [x**2 for x in range(5)]\nprint(\"Squares:\", squares)",
    "explanation": "Lists are ordered, mutable sequences. They support indexing (including negative), slicing, and list comprehensions for creating new lists efficiently.",
    "output": "Empty list: []\nFruits: ['apple', 'banana', 'cherry']\nFirst fruit: apple\nLast fruit: cherry\nLength: 3\nAfter adding: ['apple', 'blueberry', 'banana', 'cherry', 'date']\nFirst two: ['apple', 'blueberry']\nLast two: ['cherry', 'date']\nSquares: [0, 1, 4, 9, 16]",
    "order": 8
  },
  {
    "id": 9,
    "title": "Tuples",
    "slug": "tuples",
    "description": "Tuples are immutable sequences.",
    "code": "a = (\"apple\", \"banana\")\nprint(a)\nprint(\"First:\", a[0])\nprint(\"Length:\", len(a))\n\nfruit1, fruit2 = a\nprint(\"Unpacked:\", fruit1, fruit2)",
    "explanation": "Tuples are ordered, immutable sequences. Tuple unpacking allows assigning multiple variables at once.",
    "output": "('apple', 'banana')\nFirst: apple\nLength: 2\nUnpacked: apple banana",
    "order": 9
  },
  {
    "id": 10,
    "title": "List Slicing",
    "slug": "list-slicing",
    "description": "Slicing allows extracting portions of lists.",
    "code": "numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(\"Original:\", numbers)\nprint(\"[2:5]:\", numbers[2:5])\nprint(\"[:4]:\", numbers[:4])\nprint(\"[6:]:\", numbers[6:])\nprint(\"[::-1]:\", numbers[::-1])",
    "explanation": "Slicing extracts subsequences. The syntax is [start:stop:step].",
    "output": "Original: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[2:5]: [2, 3, 4]\n[:4]: [0, 1, 2, 3]\n[6:]: [6, 7, 8, 9]\n[::-1]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]",
    "order": 10
  },
  {
    "id": 11,
    "title": "Dictionaries",
    "slug": "dictionaries",
    "description": "Dictionaries are Python's built-in mapping type.",
    "code": "m = {}\nm[\"k1\"] = 7\nm[\"k2\"] = 13\nprint(\"map:\", m)\nprint(\"len:\", len(m))\n\nv1 = m[\"k1\"]\nprint(\"v1:\", v1)\n\ndel m[\"k2\"]\nprint(\"map:\", m)",
    "explanation": "Dictionaries store key-value pairs. Use square brackets to access values.",
    "output": "map: {'k1': 7, 'k2': 13}\nlen: 2\nv1: 7\nmap: {'k1': 7}",
    "order": 11
  },
  {
    "id": 12,
    "title": "Functions",
    "slug": "functions",
    "description": "Functions are central in Python.",
    "code": "# Basic function with return value\ndef add_numbers(a, b):\n    \"\"\"Add two numbers and return the result.\"\"\"\n    return a + b\n\nresult = add_numbers(10, 5)\nprint(f\"10 + 5 = {result}\")\n\n# Function with default parameters\ndef greet(name, greeting=\"Hello\", punctuation=\"!\"):\n    return f\"{greeting}, {name}{punctuation}\"\n\nprint(greet(\"Alice\"))\nprint(greet(\"Bob\", \"Hi\"))\nprint(greet(\"Charlie\", \"Welcome\", \".\"))\n\n# Function with *args and **kwargs\ndef flexible_function(*args, **kwargs):\n    print(f\"Args: {args}\")\n    print(f\"Kwargs: {kwargs}\")\n    return len(args) + len(kwargs)\n\ncount = flexible_function(1, 2, 3, name=\"Python\", version=3.9)\nprint(f\"Total arguments: {count}\")",
    "explanation": "Python functions support default parameters, variable arguments (*args), and keyword arguments (**kwargs). Docstrings provide function documentation.",
    "output": "10 + 5 = 15\nHello, Alice!\nHi, Bob!\nWelcome, Charlie.\nArgs: (1, 2, 3)\nKwargs: {'name': 'Python', 'version': 3.9}\nTotal arguments: 5",
    "order": 12
  },
  {
    "id": 13,
    "title": "Multiple Return Values",
    "slug": "multiple-return-values",
    "description": "Python supports multiple return values via tuples.",
    "code": "# Functions can return multiple values using tuples\ndef vals():\n    return 3, 7\n\n# Unpack the returned tuple\na, b = vals()\nprint(a)\nprint(b)\n\n# Use underscore to ignore values you don't need\n_, c = vals()\nprint(\"Only second:\", c)",
    "explanation": "Python's tuple unpacking makes it easy to return and handle multiple values.",
    "output": "3\n7\nOnly second: 7",
    "order": 13
  },
  {
    "id": 14,
    "title": "Variadic Functions",
    "slug": "variadic-functions",
    "description": "Variadic functions accept any number of arguments.",
    "code": "#!/usr/bin/env python3\n# variadic-functions.py\n# Functions that accept variable number of arguments\n\n# Function with *args (variable positional arguments)\ndef sum_numbers(*nums):\n    \"\"\"Sum any number of arguments\"\"\"\n    total = 0\n    print(f\"Received {len(nums)} numbers: {nums}\")\n    for num in nums:\n        total += num\n    return total\n\n# Function with **kwargs (variable keyword arguments)\ndef print_person(**kwargs):\n    \"\"\"Print person details from keyword arguments\"\"\"\n    print(\"Person details:\")\n    for key, value in kwargs.items():\n        print(f\"  {key}: {value}\")\n\n# Function with both *args and **kwargs\ndef flexible_function(*args, **kwargs):\n    \"\"\"Function accepting both types of variable arguments\"\"\"\n    print(f\"Positional args: {args}\")\n    print(f\"Keyword args: {kwargs}\")\n    return len(args) + len(kwargs)\n\n# Testing the functions\nprint(\"=== sum_numbers examples ===\")\nprint(f\"sum_numbers(1, 2) = {sum_numbers(1, 2)}\")\nprint(f\"sum_numbers(1, 2, 3, 4) = {sum_numbers(1, 2, 3, 4)}\")\n\n# Unpacking a list\nnums = [1, 2, 3]\nprint(f\"sum_numbers(*nums) = {sum_numbers(*nums)}\")\n\nprint(\"\\n=== print_person examples ===\")\nprint_person(name=\"Alice\", age=30, city=\"New York\")\n\nprint(\"\\n=== flexible_function examples ===\")\ncount = flexible_function(1, 2, 3, name=\"test\", version=1.0)\nprint(f\"Total arguments: {count}\")",
    "explanation": "Use *args to accept any number of positional arguments and **kwargs for keyword arguments. The * operator unpacks sequences, and ** unpacks dictionaries. Functions can combine both for maximum flexibility.",
    "output": "$ python variadic-functions.py\n=== sum_numbers examples ===\nReceived 2 numbers: (1, 2)\nsum_numbers(1, 2) = 3\nReceived 4 numbers: (1, 2, 3, 4)\nsum_numbers(1, 2, 3, 4) = 10\nReceived 3 numbers: (1, 2, 3)\nsum_numbers(*nums) = 6\n\n=== print_person examples ===\nPerson details:\n  name: Alice\n  age: 30\n  city: New York\n\n=== flexible_function examples ===\nPositional args: (1, 2, 3)\nKeyword args: {'name': 'test', 'version': 1.0}\nTotal arguments: 5",
    "order": 14
  },
  {
    "id": 15,
    "title": "Closures",
    "slug": "closures",
    "description": "Python supports closures.",
    "code": "def int_seq():\n    i = 0\n    def next_val():\n        nonlocal i\n        i += 1\n        return i\n    return next_val\n\nnext_int = int_seq()\nprint(next_int())\nprint(next_int())\nprint(next_int())",
    "explanation": "Closures allow inner functions to access variables from outer scope. Use nonlocal to modify them.",
    "output": "1\n2\n3",
    "order": 15
  },
  {
    "id": 16,
    "title": "Recursion",
    "slug": "recursion",
    "description": "Python supports recursive functions.",
    "code": "def fact(n):\n    if n == 0:\n        return 1\n    return n * fact(n-1)\n\nprint(fact(7))\n\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\nprint(fib(7))",
    "explanation": "Recursive functions call themselves. Base cases prevent infinite recursion.",
    "output": "5040\n13",
    "order": 16
  },
  {
    "id": 17,
    "title": "Iteration",
    "slug": "iteration",
    "description": "Python's for loops iterate over various built-in types.",
    "code": "nums = [2, 3, 4]\nsum_val = 0\nfor num in nums:\n    sum_val += num\nprint(\"sum:\", sum_val)\n\nfor i, num in enumerate(nums):\n    if num == 3:\n        print(\"index:\", i)",
    "explanation": "Python's for loop works with any iterable. Use enumerate() to get indices.",
    "output": "sum: 9\nindex: 1",
    "order": 17
  },
  {
    "id": 18,
    "title": "References",
    "slug": "references",
    "description": "Python uses object references.",
    "code": "def zero_val(ival):\n    ival = 0\n\ndef zero_ptr(iptr):\n    iptr[0] = 0\n\ni = 1\nzero_val(i)\nprint(\"zero_val:\", i)\n\niptr = [1]\nzero_ptr(iptr)\nprint(\"zero_ptr:\", iptr[0])",
    "explanation": "Python passes object references. Immutable objects can't be modified, but mutable objects can be.",
    "output": "zero_val: 1\nzero_ptr: 0",
    "order": 18
  },
  {
    "id": 19,
    "title": "Strings and Unicode",
    "slug": "strings-unicode",
    "description": "Python strings are Unicode by default.",
    "code": "s = \"hello\"\nprint(\"Length:\", len(s))\nprint(\"Char at 1:\", s[1])\nprint(\"Substring:\", s[1:3])\nprint(\"Contains 'll':\", \"ll\" in s)\nprint(\"Replace:\", s.replace(\"l\", \"L\"))",
    "explanation": "Python 3 strings are Unicode by default. They support slicing, searching, and various methods.",
    "output": "Length: 5\nChar at 1: e\nSubstring: el\nContains 'll': True\nReplace: heLLo",
    "order": 19
  },
  {
    "id": 20,
    "title": "Classes",
    "slug": "classes",
    "description": "Python supports classes and objects.",
    "code": "class Person:\n    def __init__(self, name):\n        self.name = name\n    \n    def greet(self):\n        return f\"Hello, I'm {self.name}\"\n\np = Person(\"Alice\")\nprint(p.greet())\nprint(\"Name:\", p.name)",
    "explanation": "Classes define object types. __init__ is the constructor. Methods take self as the first parameter.",
    "output": "Hello, I'm Alice\nName: Alice",
    "order": 20
  },
  {
    "id": 21,
    "title": "Methods",
    "slug": "methods",
    "description": "Python methods are functions associated with objects.",
    "code": "class Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n\nr = Rectangle(10, 5)\nprint(\"Area:\", r.area())",
    "explanation": "Methods are functions defined inside a class. They operate on the object's data.",
    "output": "Area: 50",
    "order": 21
  },
  {
    "id": 22,
    "title": "Duck Typing",
    "slug": "duck-typing",
    "description": "Python uses duck typing.",
    "code": "class Duck:\n    def quack(self):\n        return \"Quack!\"\n\nclass Dog:\n    def quack(self):\n        return \"Woof!\"\n\ndef make_it_quack(animal):\n    return animal.quack()\n\nprint(make_it_quack(Duck()))\nprint(make_it_quack(Dog()))",
    "explanation": "Duck typing means the type is less important than the methods it defines.",
    "output": "Quack!\nWoof!",
    "order": 22
  },
  {
    "id": 23,
    "title": "Enums",
    "slug": "enums",
    "description": "Python supports enumerations via the enum module.",
    "code": "from enum import Enum\n\nclass Direction(Enum):\n    NORTH = 1\n    SOUTH = 2\n    EAST = 3\n    WEST = 4\n\nprint(Direction.NORTH)\nprint(Direction.NORTH.name)\nprint(Direction.NORTH.value)",
    "explanation": "Enums provide a way to create named constants. Each enum member has a name and a value.",
    "output": "Direction.NORTH\nNORTH\n1",
    "order": 23
  },
  {
    "id": 24,
    "title": "Inheritance",
    "slug": "inheritance",
    "description": "Python supports inheritance and composition.",
    "code": "class Animal:\n    def __init__(self, name):\n        self.name = name\n    \n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return f\"{self.name} barks\"\n\ndog = Dog(\"Buddy\")\nprint(dog.speak())",
    "explanation": "Inheritance allows classes to inherit methods and attributes from parent classes.",
    "output": "Buddy barks",
    "order": 24
  },
  {
    "id": 25,
    "title": "Generics",
    "slug": "generics",
    "description": "Python supports generic types through type hints.",
    "code": "from typing import TypeVar, Generic, List\n\nT = TypeVar('T')\n\nclass Stack(Generic[T]):\n    def __init__(self):\n        self._items: List[T] = []\n    \n    def push(self, item: T):\n        self._items.append(item)\n    \n    def pop(self) -> T:\n        return self._items.pop()\n\nstack = Stack[int]()\nstack.push(1)\nprint(stack.pop())",
    "explanation": "Generics allow you to write code that works with multiple types while maintaining type safety.",
    "output": "1",
    "order": 25
  },
  {
    "id": 26,
    "title": "Iterators",
    "slug": "iterators",
    "description": "Iterators implement the iterator protocol.",
    "code": "class Counter:\n    def __init__(self, start, end):\n        self.current = start\n        self.end = end\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self.current < self.end:\n            num = self.current\n            self.current += 1\n            return num\n        else:\n            raise StopIteration\n\nfor num in Counter(1, 4):\n    print(num)",
    "explanation": "Iterators implement __iter__ and __next__ methods for the iteration protocol.",
    "output": "1\n2\n3",
    "order": 26
  },
  {
    "id": 27,
    "title": "Exceptions",
    "slug": "exceptions",
    "description": "Python uses exceptions for error handling.",
    "code": "def may_panic():\n    raise Exception(\"a problem\")\n\ntry:\n    may_panic()\nexcept Exception as e:\n    print(\"Caught:\", e)\n\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")",
    "explanation": "Use try/except to handle exceptions. Different exception types can be caught separately.",
    "output": "Caught: a problem\nCannot divide by zero",
    "order": 27
  },
  {
    "id": 28,
    "title": "Custom Exceptions",
    "slug": "custom-exceptions",
    "description": "You can create custom exception types.",
    "code": "class MyError(Exception):\n    def __init__(self, message, code):\n        super().__init__(message)\n        self.code = code\n\ndef risky_function():\n    raise MyError(\"Something went wrong\", 42)\n\ntry:\n    risky_function()\nexcept MyError as e:\n    print(f\"Error: {e}\")\n    print(f\"Code: {e.code}\")",
    "explanation": "Custom exceptions inherit from Exception. They can carry additional data beyond the error message.",
    "output": "Error: Something went wrong\nCode: 42",
    "order": 28
  },
  {
    "id": 29,
    "title": "Threads",
    "slug": "threads",
    "description": "Python supports threading for concurrent execution.",
    "code": "import threading\nimport time\n\ndef worker(name):\n    for i in range(2):\n        print(f\"Worker {name}: {i}\")\n        time.sleep(0.01)\n\nthread1 = threading.Thread(target=worker, args=(\"A\",))\nthread2 = threading.Thread(target=worker, args=(\"B\",))\n\nthread1.start()\nthread2.start()\nthread1.join()\nthread2.join()",
    "explanation": "Threading allows concurrent execution. Use join() to wait for threads to complete.",
    "output": "Worker A: 0\nWorker B: 0\nWorker A: 1\nWorker B: 1",
    "order": 29
  },
  {
    "id": 30,
    "title": "Coroutines",
    "slug": "coroutines",
    "description": "Python supports coroutines with async/await.",
    "code": "import asyncio\n\nasync def say_hello(name):\n    print(f\"Hello, {name}!\")\n    await asyncio.sleep(0.1)\n    print(f\"Goodbye, {name}!\")\n\nasync def main():\n    await asyncio.gather(\n        say_hello(\"Alice\"),\n        say_hello(\"Bob\")\n    )\n\n# In real code: asyncio.run(main())\nprint(\"Async example setup complete\")",
    "explanation": "Coroutines enable asynchronous programming. Use async def to define coroutines and await to call them.",
    "output": "Async example setup complete",
    "order": 30
  },
  {
    "id": 31,
    "title": "Custom Errors",
    "slug": "custom-errors",
    "description": "Python supports custom error types by extending Exception.",
    "code": "# Define a custom error type by extending Exception\nclass argError(Exception):\n    def __init__(self, arg, prob):\n        self.arg = arg\n        self.prob = prob\n    \n    def __str__(self):\n        return f\"{self.arg} - {self.prob}\"\n\n# Function that might return a custom error\ndef f(arg):\n    if arg == 42:\n        # Return both a value and error (Go-style)\n        return -1, argError(arg, \"can't work with it\")\n    # Normal return\n    return arg + 3, None\n\n# Use the function\nresult, err = f(42)\nif err:\n    print(f\"Error: {err}\")\nelse:\n    print(f\"Result: {result}\")\n\n# Normal case\nresult, err = f(7)\nif err:\n    print(f\"Error: {err}\")\nelse:\n    print(f\"Result: {result}\")",
    "explanation": "Custom errors let you create domain-specific error types. This example shows a Go-style error handling pattern with tuple returns.",
    "output": "Error: 42 - can't work with it\nResult: 10",
    "order": 31
  }
]