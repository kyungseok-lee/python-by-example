[
  {
    "id": 1,
    "title": "Hello World",
    "slug": "hello-world",
    "description": "Our first program will print the classic \"hello world\" message.",
    "code": "print(\"hello world\")",
    "explanation": "To run the program, put the code in hello-world.py and use python.",
    "output": "hello world",
    "order": 1
  },
  {
    "id": 2,
    "title": "Literals",
    "slug": "literals",
    "description": "Python has various value types including strings, integers, floats, booleans, etc.",
    "code": "# String literals and concatenation\nprint(\"python\" + \"rocks\")\nprint(\"Hello\", \"World\")\n\n# Integer and float arithmetic\nprint(\"1+1 =\", 1+1)\nprint(\"7.0/3.0 =\", 7.0/3.0)\nprint(\"10//3 =\", 10//3)  # Floor division\nprint(\"10%3 =\", 10%3)   # Modulo\n\n# Boolean operations\nprint(\"True and False:\", True and False)\nprint(\"True or False:\", True or False)\nprint(\"not True:\", not True)",
    "explanation": "Python supports various literal types. Strings can be concatenated with + or printed with commas. Numbers support arithmetic operations including floor division (//) and modulo (%). Booleans work with logical operators and, or, not.",
    "output": "pythonrocks\nHello World\n1+1 = 2\n7.0/3.0 = 2.3333333333333335\n10//3 = 3\n10%3 = 1\nTrue and False: False\nTrue or False: True\nnot True: False",
    "order": 2
  },
  {
    "id": 3,
    "title": "Variables",
    "slug": "variables",
    "description": "In Python, variables are declared and assigned with =.",
    "code": "a = \"initial\"\nprint(a)\n\nb = 1\nc = 2\nprint(b, c)\n\nd = True\nprint(d)",
    "explanation": "Python uses dynamic typing - you don't need to declare variable types explicitly.",
    "output": "initial\n1 2\nTrue",
    "order": 3
  },
  {
    "id": 4,
    "title": "Constants",
    "slug": "constants",
    "description": "Python supports constants by convention using UPPERCASE names.",
    "code": "PI = 3.14159\nMAX_SIZE = 100\nprint(\"PI:\", PI)\nprint(\"MAX_SIZE:\", MAX_SIZE)",
    "explanation": "Python doesn't have built-in constants. By convention, variables in ALL_CAPS are treated as constants.",
    "output": "PI: 3.14159\nMAX_SIZE: 100",
    "order": 4
  },
  {
    "id": 5,
    "title": "For Loops",
    "slug": "for-loops",
    "description": "for is Python's primary looping construct.",
    "code": "for j in range(1, 4):\n    print(j)\n\nfor i in range(10):\n    if i >= 2:\n        break\n    print(\"loop\")\n\nfor n in range(6):\n    if n % 2 == 0:\n        continue\n    print(n)",
    "explanation": "Python's for loop iterates over sequences. break exits the loop, continue skips to the next iteration.",
    "output": "1\n2\n3\nloop\nloop\n1\n3\n5",
    "order": 5
  },
  {
    "id": 6,
    "title": "If / Else",
    "slug": "if-else",
    "description": "Branching with if and else in Python is straightforward.",
    "code": "if 7 % 2 == 0:\n    print(\"7 is even\")\nelse:\n    print(\"7 is odd\")\n\nif 8 % 4 == 0:\n    print(\"8 is divisible by 4\")\n\nnum = 9\nprint(\"9 is odd\" if num % 2 == 1 else \"9 is even\")",
    "explanation": "Python uses if, elif, and else for conditional statements. The ternary operator provides concise conditionals.",
    "output": "7 is odd\n8 is divisible by 4\n9 is odd",
    "order": 6
  },
  {
    "id": 7,
    "title": "Pattern Matching",
    "slug": "pattern-matching",
    "description": "Python 3.10+ supports pattern matching with match/case statements.",
    "code": "def describe_animal(animal):\n    match animal:\n        case \"dog\":\n            return \"loyal companion\"\n        case \"cat\":\n            return \"independent hunter\"\n        case _:\n            return \"unknown animal\"\n\nprint(describe_animal(\"dog\"))\nprint(describe_animal(\"fish\"))",
    "explanation": "Pattern matching with match/case statements was introduced in Python 3.10. The underscore (_) acts as a wildcard.",
    "output": "loyal companion\nunknown animal",
    "order": 7
  },
  {
    "id": 8,
    "title": "Lists",
    "slug": "lists",
    "description": "Lists are Python's basic sequence type.",
    "code": "# Creating and working with lists\nmy_list = []\nprint(\"Empty list:\", my_list)\n\n# List with initial values\nfruits = [\"apple\", \"banana\", \"cherry\"]\nprint(\"Fruits:\", fruits)\nprint(\"First fruit:\", fruits[0])\nprint(\"Last fruit:\", fruits[-1])  # Negative indexing\nprint(\"Length:\", len(fruits))\n\n# Adding elements\nfruits.append(\"date\")\nfruits.insert(1, \"blueberry\")  # Insert at index 1\nprint(\"After adding:\", fruits)\n\n# List slicing\nprint(\"First two:\", fruits[:2])\nprint(\"Last two:\", fruits[-2:])\n\n# List comprehension\nsquares = [x**2 for x in range(5)]\nprint(\"Squares:\", squares)",
    "explanation": "Lists are ordered, mutable sequences. They support indexing (including negative), slicing, and list comprehensions for creating new lists efficiently.",
    "output": "Empty list: []\nFruits: ['apple', 'banana', 'cherry']\nFirst fruit: apple\nLast fruit: cherry\nLength: 3\nAfter adding: ['apple', 'blueberry', 'banana', 'cherry', 'date']\nFirst two: ['apple', 'blueberry']\nLast two: ['cherry', 'date']\nSquares: [0, 1, 4, 9, 16]",
    "order": 8
  },
  {
    "id": 9,
    "title": "Tuples",
    "slug": "tuples",
    "description": "Tuples are immutable sequences.",
    "code": "a = (\"apple\", \"banana\")\nprint(a)\nprint(\"First:\", a[0])\nprint(\"Length:\", len(a))\n\nfruit1, fruit2 = a\nprint(\"Unpacked:\", fruit1, fruit2)",
    "explanation": "Tuples are ordered, immutable sequences. Tuple unpacking allows assigning multiple variables at once.",
    "output": "('apple', 'banana')\nFirst: apple\nLength: 2\nUnpacked: apple banana",
    "order": 9
  },
  {
    "id": 10,
    "title": "List Slicing",
    "slug": "list-slicing",
    "description": "Slicing allows extracting portions of lists.",
    "code": "numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(\"Original:\", numbers)\nprint(\"[2:5]:\", numbers[2:5])\nprint(\"[:4]:\", numbers[:4])\nprint(\"[6:]:\", numbers[6:])\nprint(\"[::-1]:\", numbers[::-1])",
    "explanation": "Slicing extracts subsequences. The syntax is [start:stop:step].",
    "output": "Original: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[2:5]: [2, 3, 4]\n[:4]: [0, 1, 2, 3]\n[6:]: [6, 7, 8, 9]\n[::-1]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]",
    "order": 10
  },
  {
    "id": 11,
    "title": "Dictionaries",
    "slug": "dictionaries",
    "description": "Dictionaries are Python's built-in mapping type.",
    "code": "m = {}\nm[\"k1\"] = 7\nm[\"k2\"] = 13\nprint(\"map:\", m)\nprint(\"len:\", len(m))\n\nv1 = m[\"k1\"]\nprint(\"v1:\", v1)\n\ndel m[\"k2\"]\nprint(\"map:\", m)",
    "explanation": "Dictionaries store key-value pairs. Use square brackets to access values.",
    "output": "map: {'k1': 7, 'k2': 13}\nlen: 2\nv1: 7\nmap: {'k1': 7}",
    "order": 11
  },
  {
    "id": 12,
    "title": "Functions",
    "slug": "functions",
    "description": "Functions are central in Python.",
    "code": "# Basic function with return value\ndef add_numbers(a, b):\n    \"\"\"Add two numbers and return the result.\"\"\"\n    return a + b\n\nresult = add_numbers(10, 5)\nprint(f\"10 + 5 = {result}\")\n\n# Function with default parameters\ndef greet(name, greeting=\"Hello\", punctuation=\"!\"):\n    return f\"{greeting}, {name}{punctuation}\"\n\nprint(greet(\"Alice\"))\nprint(greet(\"Bob\", \"Hi\"))\nprint(greet(\"Charlie\", \"Welcome\", \".\"))\n\n# Function with *args and **kwargs\ndef flexible_function(*args, **kwargs):\n    print(f\"Args: {args}\")\n    print(f\"Kwargs: {kwargs}\")\n    return len(args) + len(kwargs)\n\ncount = flexible_function(1, 2, 3, name=\"Python\", version=3.9)\nprint(f\"Total arguments: {count}\")",
    "explanation": "Python functions support default parameters, variable arguments (*args), and keyword arguments (**kwargs). Docstrings provide function documentation.",
    "output": "10 + 5 = 15\nHello, Alice!\nHi, Bob!\nWelcome, Charlie.\nArgs: (1, 2, 3)\nKwargs: {'name': 'Python', 'version': 3.9}\nTotal arguments: 5",
    "order": 12
  },
  {
    "id": 13,
    "title": "Multiple Return Values",
    "slug": "multiple-return-values",
    "description": "Python supports multiple return values via tuples.",
    "code": "# Functions can return multiple values using tuples\ndef vals():\n    return 3, 7\n\n# Unpack the returned tuple\na, b = vals()\nprint(a)\nprint(b)\n\n# Use underscore to ignore values you don't need\n_, c = vals()\nprint(\"Only second:\", c)",
    "explanation": "Python's tuple unpacking makes it easy to return and handle multiple values.",
    "output": "3\n7\nOnly second: 7",
    "order": 13
  },
  {
    "id": 14,
    "title": "Variadic Functions",
    "slug": "variadic-functions",
    "description": "Variadic functions accept any number of arguments.",
    "code": "def sum_numbers(*nums):\n    total = 0\n    for num in nums:\n        total += num\n    return total\n\nprint(sum_numbers(1, 2))\nprint(sum_numbers(1, 2, 3, 4))\n\nnums = [1, 2, 3]\nprint(sum_numbers(*nums))",
    "explanation": "Use *args to accept any number of positional arguments. The * operator unpacks sequences.",
    "output": "3\n10\n6",
    "order": 14
  },
  {
    "id": 15,
    "title": "Closures",
    "slug": "closures",
    "description": "Python supports closures.",
    "code": "def int_seq():\n    i = 0\n    def next_val():\n        nonlocal i\n        i += 1\n        return i\n    return next_val\n\nnext_int = int_seq()\nprint(next_int())\nprint(next_int())\nprint(next_int())",
    "explanation": "Closures allow inner functions to access variables from outer scope. Use nonlocal to modify them.",
    "output": "1\n2\n3",
    "order": 15
  },
  {
    "id": 16,
    "title": "Recursion",
    "slug": "recursion",
    "description": "Python supports recursive functions.",
    "code": "def fact(n):\n    if n == 0:\n        return 1\n    return n * fact(n-1)\n\nprint(fact(7))\n\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\nprint(fib(7))",
    "explanation": "Recursive functions call themselves. Base cases prevent infinite recursion.",
    "output": "5040\n13",
    "order": 16
  },
  {
    "id": 17,
    "title": "Iteration",
    "slug": "iteration",
    "description": "Python's for loops iterate over various built-in types.",
    "code": "nums = [2, 3, 4]\nsum_val = 0\nfor num in nums:\n    sum_val += num\nprint(\"sum:\", sum_val)\n\nfor i, num in enumerate(nums):\n    if num == 3:\n        print(\"index:\", i)",
    "explanation": "Python's for loop works with any iterable. Use enumerate() to get indices.",
    "output": "sum: 9\nindex: 1",
    "order": 17
  },
  {
    "id": 18,
    "title": "References",
    "slug": "references",
    "description": "Python uses object references.",
    "code": "def zero_val(ival):\n    ival = 0\n\ndef zero_ptr(iptr):\n    iptr[0] = 0\n\ni = 1\nzero_val(i)\nprint(\"zero_val:\", i)\n\niptr = [1]\nzero_ptr(iptr)\nprint(\"zero_ptr:\", iptr[0])",
    "explanation": "Python passes object references. Immutable objects can't be modified, but mutable objects can be.",
    "output": "zero_val: 1\nzero_ptr: 0",
    "order": 18
  },
  {
    "id": 19,
    "title": "Strings and Unicode",
    "slug": "strings-unicode",
    "description": "Python strings are Unicode by default.",
    "code": "s = \"hello\"\nprint(\"Length:\", len(s))\nprint(\"Char at 1:\", s[1])\nprint(\"Substring:\", s[1:3])\nprint(\"Contains 'll':\", \"ll\" in s)\nprint(\"Replace:\", s.replace(\"l\", \"L\"))",
    "explanation": "Python 3 strings are Unicode by default. They support slicing, searching, and various methods.",
    "output": "Length: 5\nChar at 1: e\nSubstring: el\nContains 'll': True\nReplace: heLLo",
    "order": 19
  },
  {
    "id": 20,
    "title": "Classes",
    "slug": "classes",
    "description": "Python supports classes and objects.",
    "code": "class Person:\n    def __init__(self, name):\n        self.name = name\n    \n    def greet(self):\n        return f\"Hello, I'm {self.name}\"\n\np = Person(\"Alice\")\nprint(p.greet())\nprint(\"Name:\", p.name)",
    "explanation": "Classes define object types. __init__ is the constructor. Methods take self as the first parameter.",
    "output": "Hello, I'm Alice\nName: Alice",
    "order": 20
  },
  {
    "id": 21,
    "title": "Methods",
    "slug": "methods",
    "description": "Python methods are functions associated with objects.",
    "code": "class Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n\nr = Rectangle(10, 5)\nprint(\"Area:\", r.area())",
    "explanation": "Methods are functions defined inside a class. They operate on the object's data.",
    "output": "Area: 50",
    "order": 21
  },
  {
    "id": 22,
    "title": "Duck Typing",
    "slug": "duck-typing",
    "description": "Python uses duck typing.",
    "code": "class Duck:\n    def quack(self):\n        return \"Quack!\"\n\nclass Dog:\n    def quack(self):\n        return \"Woof!\"\n\ndef make_it_quack(animal):\n    return animal.quack()\n\nprint(make_it_quack(Duck()))\nprint(make_it_quack(Dog()))",
    "explanation": "Duck typing means the type is less important than the methods it defines.",
    "output": "Quack!\nWoof!",
    "order": 22
  },
  {
    "id": 23,
    "title": "Enums",
    "slug": "enums",
    "description": "Python supports enumerations via the enum module.",
    "code": "from enum import Enum\n\nclass Direction(Enum):\n    NORTH = 1\n    SOUTH = 2\n    EAST = 3\n    WEST = 4\n\nprint(Direction.NORTH)\nprint(Direction.NORTH.name)\nprint(Direction.NORTH.value)",
    "explanation": "Enums provide a way to create named constants. Each enum member has a name and a value.",
    "output": "Direction.NORTH\nNORTH\n1",
    "order": 23
  },
  {
    "id": 24,
    "title": "Inheritance",
    "slug": "inheritance",
    "description": "Python supports inheritance and composition.",
    "code": "class Animal:\n    def __init__(self, name):\n        self.name = name\n    \n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return f\"{self.name} barks\"\n\ndog = Dog(\"Buddy\")\nprint(dog.speak())",
    "explanation": "Inheritance allows classes to inherit methods and attributes from parent classes.",
    "output": "Buddy barks",
    "order": 24
  },
  {
    "id": 25,
    "title": "Generics",
    "slug": "generics",
    "description": "Python supports generic types through type hints.",
    "code": "from typing import TypeVar, Generic, List\n\nT = TypeVar('T')\n\nclass Stack(Generic[T]):\n    def __init__(self):\n        self._items: List[T] = []\n    \n    def push(self, item: T):\n        self._items.append(item)\n    \n    def pop(self) -> T:\n        return self._items.pop()\n\nstack = Stack[int]()\nstack.push(1)\nprint(stack.pop())",
    "explanation": "Generics allow you to write code that works with multiple types while maintaining type safety.",
    "output": "1",
    "order": 25
  },
  {
    "id": 26,
    "title": "Iterators",
    "slug": "iterators",
    "description": "Iterators implement the iterator protocol.",
    "code": "class Counter:\n    def __init__(self, start, end):\n        self.current = start\n        self.end = end\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self.current < self.end:\n            num = self.current\n            self.current += 1\n            return num\n        else:\n            raise StopIteration\n\nfor num in Counter(1, 4):\n    print(num)",
    "explanation": "Iterators implement __iter__ and __next__ methods for the iteration protocol.",
    "output": "1\n2\n3",
    "order": 26
  },
  {
    "id": 27,
    "title": "Exceptions",
    "slug": "exceptions",
    "description": "Python uses exceptions for error handling.",
    "code": "def may_panic():\n    raise Exception(\"a problem\")\n\ntry:\n    may_panic()\nexcept Exception as e:\n    print(\"Caught:\", e)\n\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")",
    "explanation": "Use try/except to handle exceptions. Different exception types can be caught separately.",
    "output": "Caught: a problem\nCannot divide by zero",
    "order": 27
  },
  {
    "id": 28,
    "title": "Custom Exceptions",
    "slug": "custom-exceptions",
    "description": "You can create custom exception types.",
    "code": "class MyError(Exception):\n    def __init__(self, message, code):\n        super().__init__(message)\n        self.code = code\n\ndef risky_function():\n    raise MyError(\"Something went wrong\", 42)\n\ntry:\n    risky_function()\nexcept MyError as e:\n    print(f\"Error: {e}\")\n    print(f\"Code: {e.code}\")",
    "explanation": "Custom exceptions inherit from Exception. They can carry additional data beyond the error message.",
    "output": "Error: Something went wrong\nCode: 42",
    "order": 28
  },
  {
    "id": 29,
    "title": "Threads",
    "slug": "threads",
    "description": "Python supports threading for concurrent execution.",
    "code": "import threading\nimport time\n\ndef worker(name):\n    for i in range(2):\n        print(f\"Worker {name}: {i}\")\n        time.sleep(0.01)\n\nthread1 = threading.Thread(target=worker, args=(\"A\",))\nthread2 = threading.Thread(target=worker, args=(\"B\",))\n\nthread1.start()\nthread2.start()\nthread1.join()\nthread2.join()",
    "explanation": "Threading allows concurrent execution. Use join() to wait for threads to complete.",
    "output": "Worker A: 0\nWorker B: 0\nWorker A: 1\nWorker B: 1",
    "order": 29
  },
  {
    "id": 30,
    "title": "Coroutines",
    "slug": "coroutines",
    "description": "Python supports coroutines with async/await.",
    "code": "import asyncio\n\nasync def say_hello(name):\n    print(f\"Hello, {name}!\")\n    await asyncio.sleep(0.1)\n    print(f\"Goodbye, {name}!\")\n\nasync def main():\n    await asyncio.gather(\n        say_hello(\"Alice\"),\n        say_hello(\"Bob\")\n    )\n\n# In real code: asyncio.run(main())\nprint(\"Async example setup complete\")",
    "explanation": "Coroutines enable asynchronous programming. Use async def to define coroutines and await to call them.",
    "output": "Async example setup complete",
    "order": 30
  },
  {
    "id": 31,
    "title": "Custom Errors",
    "slug": "custom-errors",
    "description": "Python supports custom error types by extending Exception.",
    "code": "# Define a custom error type by extending Exception\nclass argError(Exception):\n    def __init__(self, arg, prob):\n        self.arg = arg\n        self.prob = prob\n    \n    def __str__(self):\n        return f\"{self.arg} - {self.prob}\"\n\n# Function that might return a custom error\ndef f(arg):\n    if arg == 42:\n        # Return both a value and error (Go-style)\n        return -1, argError(arg, \"can't work with it\")\n    # Normal return\n    return arg + 3, None\n\n# Use the function\nresult, err = f(42)\nif err:\n    print(f\"Error: {err}\")\nelse:\n    print(f\"Result: {result}\")\n\n# Normal case\nresult, err = f(7)\nif err:\n    print(f\"Error: {err}\")\nelse:\n    print(f\"Result: {result}\")",
    "explanation": "Custom errors let you create domain-specific error types. This example shows a Go-style error handling pattern with tuple returns.",
    "output": "Error: 42 - can't work with it\nResult: 10",
    "order": 31
  }
]