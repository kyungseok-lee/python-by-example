[
  {
    "id": 1,
    "title": "Hello World",
    "slug": "hello-world",
    "categoryId": 1,
    "description": "첫 번째 Python 프로그램을 작성해봅니다",
    "code": "# 전통적인 첫 번째 프로그램\nprint(\"Hello, World!\")\n\n# 다양한 출력 방법\nprint(\"안녕하세요!\")\nprint(\"Python\", \"Programming\")\nprint(f\"오늘은 {2024}년입니다\")",
    "explanation": "print() 함수는 텍스트나 변수의 값을 화면에 출력합니다. 여러 값을 쉼표로 구분하여 한 번에 출력할 수 있으며, f-string을 사용하여 변수를 문자열에 포함시킬 수 있습니다.",
    "output": "Hello, World!\n안녕하세요!\nPython Programming\n오늘은 2024년입니다",
    "order": 1
  },
  {
    "id": 2,
    "title": "Variables",
    "slug": "variables",
    "categoryId": 2,
    "description": "변수를 선언하고 사용하는 방법을 학습합니다",
    "code": "# 다양한 데이터 타입의 변수\nname = \"Alice\"\nage = 25\nheight = 165.5\nis_student = True\n\n# 변수 출력\nprint(f\"이름: {name}\")\nprint(f\"나이: {age}\")\nprint(f\"키: {height}cm\")\nprint(f\"학생 여부: {is_student}\")\n\n# 타입 확인\nprint(f\"name의 타입: {type(name)}\")\nprint(f\"age의 타입: {type(age)}\")",
    "explanation": "Python에서 변수는 값을 저장하는 공간입니다. = 연산자를 사용하여 값을 할당하며, type() 함수로 변수의 데이터 타입을 확인할 수 있습니다.",
    "output": "이름: Alice\n나이: 25\n키: 165.5cm\n학생 여부: True\nname의 타입: <class 'str'>\nage의 타입: <class 'int'>",
    "order": 2
  },
  {
    "id": 3,
    "title": "Strings",
    "slug": "strings",
    "categoryId": 2,
    "description": "문자열 처리와 포맷팅 방법을 배웁니다",
    "code": "# 문자열 기본 조작\ntext = \"Python Programming\"\nprint(f\"원본: {text}\")\nprint(f\"대문자: {text.upper()}\")\nprint(f\"소문자: {text.lower()}\")\nprint(f\"길이: {len(text)}\")\n\n# 문자열 슬라이싱\nprint(f\"첫 6글자: {text[:6]}\")\nprint(f\"마지막 11글자: {text[7:]}\")\n\n# 문자열 포맷팅\nname = \"김철수\"\nscore = 95\nprint(f\"{name}님의 점수는 {score}점입니다.\")",
    "explanation": "문자열은 따옴표로 둘러싸인 텍스트 데이터입니다. upper(), lower(), len() 등의 메서드로 조작할 수 있고, 슬라이싱으로 부분 문자열을 추출할 수 있습니다.",
    "output": "원본: Python Programming\n대문자: PYTHON PROGRAMMING\n소문자: python programming\n길이: 18\n첫 6글자: Python\n마지막 11글자: Programming\n김철수님의 점수는 95점입니다.",
    "order": 3
  },
  {
    "id": 4,
    "title": "Numbers",
    "slug": "numbers",
    "categoryId": 2,
    "description": "숫자 데이터 타입과 기본 연산을 학습합니다",
    "code": "# 정수와 실수\ninteger_num = 42\nfloat_num = 3.14159\n\n# 기본 산술 연산\na = 10\nb = 3\n\nprint(f\"더하기: {a} + {b} = {a + b}\")\nprint(f\"빼기: {a} - {b} = {a - b}\")\nprint(f\"곱하기: {a} * {b} = {a * b}\")\nprint(f\"나누기: {a} / {b} = {a / b}\")\nprint(f\"몫: {a} // {b} = {a // b}\")\nprint(f\"나머지: {a} % {b} = {a % b}\")\nprint(f\"거듭제곱: {a} ** {b} = {a ** b}\")",
    "explanation": "Python은 정수(int)와 실수(float) 두 가지 기본 숫자 타입을 지원합니다. 다양한 산술 연산자를 사용하여 계산할 수 있습니다.",
    "output": "더하기: 10 + 3 = 13\n빼기: 10 - 3 = 7\n곱하기: 10 * 3 = 30\n나누기: 10 / 3 = 3.3333333333333335\n몫: 10 // 3 = 3\n나머지: 10 % 3 = 1\n거듭제곱: 10 ** 3 = 1000",
    "order": 4
  },
  {
    "id": 5,
    "title": "Booleans",
    "slug": "booleans",
    "categoryId": 2,
    "description": "불린 타입과 논리 연산을 배웁니다",
    "code": "# 불린 값\nis_sunny = True\nis_raining = False\n\nprint(f\"맑음: {is_sunny}\")\nprint(f\"비옴: {is_raining}\")\n\n# 비교 연산\nage = 20\nprint(f\"성인인가? {age >= 18}\")\nprint(f\"미성년자인가? {age < 18}\")\n\n# 논리 연산\nhas_umbrella = True\nprint(f\"비가 오고 우산이 있나? {is_raining and has_umbrella}\")\nprint(f\"맑거나 우산이 있나? {is_sunny or has_umbrella}\")\nprint(f\"비가 안 온다: {not is_raining}\")",
    "explanation": "불린(Boolean) 타입은 True 또는 False 값만 가질 수 있습니다. 비교 연산자(>, <, ==)와 논리 연산자(and, or, not)와 함께 사용됩니다.",
    "output": "맑음: True\n비옴: False\n성인인가? True\n미성년자인가? False\n비가 오고 우산이 있나? False\n맑거나 우산이 있나? True\n비가 안 온다: True",
    "order": 5
  },
  {
    "id": 6,
    "title": "Operators",
    "slug": "operators",
    "categoryId": 3,
    "description": "Python의 다양한 연산자들을 학습합니다",
    "code": "# 산술 연산자\na, b = 15, 4\nprint(f\"a = {a}, b = {b}\")\nprint(f\"a + b = {a + b}\")\nprint(f\"a - b = {a - b}\")\nprint(f\"a * b = {a * b}\")\nprint(f\"a / b = {a / b}\")\nprint(f\"a // b = {a // b}\")\nprint(f\"a % b = {a % b}\")\nprint(f\"a ** b = {a ** b}\")\n\n# 비교 연산자\nprint(f\"\\n비교 연산:\")\nprint(f\"a == b: {a == b}\")\nprint(f\"a != b: {a != b}\")\nprint(f\"a > b: {a > b}\")\nprint(f\"a < b: {a < b}\")\n\n# 논리 연산자\nx, y = True, False\nprint(f\"\\n논리 연산:\")\nprint(f\"x and y: {x and y}\")\nprint(f\"x or y: {x or y}\")\nprint(f\"not x: {not x}\")",
    "explanation": "Python은 산술, 비교, 논리, 할당 등 다양한 연산자를 제공합니다. 각 연산자는 특정한 우선순위를 가지며, 괄호를 사용하여 연산 순서를 명시적으로 지정할 수 있습니다.",
    "output": "a = 15, b = 4\na + b = 19\na - b = 11\na * b = 60\na / b = 3.75\na // b = 3\na % b = 3\na ** b = 50625\n\n비교 연산:\na == b: False\na != b: True\na > b: True\na < b: False\n\n논리 연산:\nx and y: False\nx or y: True\nnot x: False",
    "order": 6
  },
  {
    "id": 7,
    "title": "If Statements",
    "slug": "if-statements",
    "categoryId": 4,
    "description": "조건문을 사용하여 프로그램의 흐름을 제어합니다",
    "code": "# 기본 if 문\nage = 18\n\nif age >= 18:\n    print(\"성인입니다.\")\nelse:\n    print(\"미성년자입니다.\")\n\n# if-elif-else 문\nscore = 85\n\nif score >= 90:\n    grade = \"A\"\nelif score >= 80:\n    grade = \"B\"\nelif score >= 70:\n    grade = \"C\"\nelif score >= 60:\n    grade = \"D\"\nelse:\n    grade = \"F\"\n\nprint(f\"점수: {score}, 등급: {grade}\")\n\n# 중첩 조건문\nweather = \"맑음\"\ntemperature = 25\n\nif weather == \"맑음\":\n    if temperature > 30:\n        print(\"덥고 맑은 날입니다.\")\n    elif temperature > 20:\n        print(\"따뜻하고 맑은 날입니다.\")\n    else:\n        print(\"춥지만 맑은 날입니다.\")\nelse:\n    print(\"날씨가 좋지 않습니다.\")",
    "explanation": "if문은 조건에 따라 코드 실행을 제어합니다. elif로 추가 조건을 검사하고, else로 모든 조건이 거짓일 때의 동작을 정의합니다. 들여쓰기로 코드 블록을 구분합니다.",
    "output": "성인입니다.\n점수: 85, 등급: B\n따뜻하고 맑은 날입니다.",
    "order": 7
  },
  {
    "id": 8,
    "title": "For Loops",
    "slug": "for-loops",
    "categoryId": 4,
    "description": "for 반복문으로 반복 작업을 수행합니다",
    "code": "# range를 사용한 반복\nprint(\"1부터 5까지:\")\nfor i in range(1, 6):\n    print(f\"숫자: {i}\")\n\n# 리스트 반복\nfruits = [\"사과\", \"바나나\", \"오렌지\"]\nprint(\"\\n과일 목록:\")\nfor fruit in fruits:\n    print(f\"- {fruit}\")\n\n# enumerate 사용\nprint(\"\\n인덱스와 함께:\")\nfor index, fruit in enumerate(fruits):\n    print(f\"{index + 1}. {fruit}\")\n\n# 중첩 반복문\nprint(\"\\n구구단 3단:\")\nfor i in range(1, 4):\n    for j in range(1, 4):\n        print(f\"{i} x {j} = {i * j}\")",
    "explanation": "for문은 시퀀스(리스트, 문자열, range 등)의 각 요소에 대해 반복 실행합니다. enumerate()를 사용하면 인덱스와 값을 동시에 얻을 수 있습니다.",
    "output": "1부터 5까지:\n숫자: 1\n숫자: 2\n숫자: 3\n숫자: 4\n숫자: 5\n\n과일 목록:\n- 사과\n- 바나나\n- 오렌지\n\n인덱스와 함께:\n1. 사과\n2. 바나나\n3. 오렌지\n\n구구단 3단:\n1 x 1 = 1\n1 x 2 = 2\n1 x 3 = 3\n2 x 1 = 2\n2 x 2 = 4\n2 x 3 = 6\n3 x 1 = 3\n3 x 2 = 6\n3 x 3 = 9",
    "order": 8
  },
  {
    "id": 9,
    "title": "While Loops",
    "slug": "while-loops",
    "categoryId": 4,
    "description": "while 반복문으로 조건부 반복을 수행합니다",
    "code": "# 기본 while 문\ncount = 1\nprint(\"1부터 5까지 카운트:\")\nwhile count <= 5:\n    print(f\"카운트: {count}\")\n    count += 1\n\n# break와 continue\nprint(\"\\n짝수만 출력 (1-10):\")\nnum = 1\nwhile num <= 10:\n    if num % 2 == 1:  # 홀수면 건너뛰기\n        num += 1\n        continue\n    print(f\"짝수: {num}\")\n    num += 1\n\n# while-else\nprint(\"\\n숫자 찾기:\")\ntarget = 7\nnum = 1\nwhile num <= 5:\n    if num == target:\n        print(f\"{target}을 찾았습니다!\")\n        break\n    num += 1\nelse:\n    print(f\"{target}을 찾지 못했습니다.\")",
    "explanation": "while문은 조건이 참인 동안 반복 실행됩니다. break로 루프를 중단하고, continue로 다음 반복으로 건너뛸 수 있습니다. while-else 구문에서 else는 break로 중단되지 않고 정상 종료될 때 실행됩니다.",
    "output": "1부터 5까지 카운트:\n카운트: 1\n카운트: 2\n카운트: 3\n카운트: 4\n카운트: 5\n\n짝수만 출력 (1-10):\n짝수: 2\n짝수: 4\n짝수: 6\n짝수: 8\n짝수: 10\n\n숫자 찾기:\n7을 찾지 못했습니다.",
    "order": 9
  },
  {
    "id": 10,
    "title": "Lists",
    "slug": "lists",
    "categoryId": 5,
    "description": "리스트의 생성, 조작, 주요 메서드를 학습합니다",
    "code": "# 리스트 생성\nnumbers = [1, 2, 3, 4, 5]\nfruits = [\"사과\", \"바나나\", \"오렌지\"]\nmixed = [1, \"hello\", 3.14, True]\n\nprint(f\"숫자 리스트: {numbers}\")\nprint(f\"과일 리스트: {fruits}\")\nprint(f\"혼합 리스트: {mixed}\")\n\n# 리스트 인덱싱과 슬라이싱\nprint(f\"\\n첫 번째 과일: {fruits[0]}\")\nprint(f\"마지막 과일: {fruits[-1]}\")\nprint(f\"처음 두 개: {fruits[:2]}\")\n\n# 리스트 조작\nfruits.append(\"포도\")  # 추가\nprint(f\"포도 추가 후: {fruits}\")\n\nfruits.insert(1, \"키위\")  # 특정 위치에 삽입\nprint(f\"키위 삽입 후: {fruits}\")\n\nfruits.remove(\"바나나\")  # 값으로 제거\nprint(f\"바나나 제거 후: {fruits}\")\n\n# 리스트 메서드\nprint(f\"\\n리스트 길이: {len(fruits)}\")\nprint(f\"사과가 있나요? {'사과' in fruits}\")\nprint(f\"정렬된 과일: {sorted(fruits)}\")",
    "explanation": "리스트는 순서가 있는 변경 가능한 컬렉션입니다. 대괄호 []로 만들며, 다양한 데이터 타입을 저장할 수 있습니다. append(), insert(), remove() 등의 메서드로 조작할 수 있습니다.",
    "output": "숫자 리스트: [1, 2, 3, 4, 5]\n과일 리스트: ['사과', '바나나', '오렌지']\n혼합 리스트: [1, 'hello', 3.14, True]\n\n첫 번째 과일: 사과\n마지막 과일: 오렌지\n처음 두 개: ['사과', '바나나']\n포도 추가 후: ['사과', '바나나', '오렌지', '포도']\n키위 삽입 후: ['사과', '키위', '바나나', '오렌지', '포도']\n바나나 제거 후: ['사과', '키위', '오렌지', '포도']\n\n리스트 길이: 4\n사과가 있나요? True\n정렬된 과일: ['사과', '오렌지', '키위', '포도']",
    "order": 10
  },
  {
    "id": 11,
    "title": "Dictionaries",
    "slug": "dictionaries",
    "categoryId": 5,
    "description": "딕셔너리의 키-값 구조와 활용법을 배웁니다",
    "code": "# 딕셔너리 생성\nstudent = {\n    \"이름\": \"김철수\",\n    \"나이\": 20,\n    \"전공\": \"컴퓨터과학\",\n    \"성적\": [85, 90, 78, 92]\n}\n\nprint(f\"학생 정보: {student}\")\n\n# 값 접근\nprint(f\"\\n이름: {student['이름']}\")\nprint(f\"나이: {student.get('나이')}\")\nprint(f\"학년: {student.get('학년', '정보 없음')}\")  # 기본값 제공\n\n# 값 수정 및 추가\nstudent[\"나이\"] = 21\nstudent[\"학년\"] = 3\nprint(f\"\\n수정 후: {student}\")\n\n# 딕셔너리 메서드\nprint(f\"\\n모든 키: {list(student.keys())}\")\nprint(f\"모든 값: {list(student.values())}\")\n\n# 딕셔너리 순회\nprint(\"\\n학생 정보 출력:\")\nfor key, value in student.items():\n    print(f\"{key}: {value}\")\n\n# 딕셔너리 삭제\ndel student[\"성적\"]\nprint(f\"\\n성적 삭제 후: {student}\")",
    "explanation": "딕셔너리는 키-값 쌍으로 데이터를 저장하는 변경 가능한 컬렉션입니다. 중괄호 {}로 만들며, 키를 통해 빠르게 값에 접근할 수 있습니다. get() 메서드는 안전한 값 접근을 제공합니다.",
    "output": "학생 정보: {'이름': '김철수', '나이': 20, '전공': '컴퓨터과학', '성적': [85, 90, 78, 92]}\n\n이름: 김철수\n나이: 20\n학년: 정보 없음\n\n수정 후: {'이름': '김철수', '나이': 21, '전공': '컴퓨터과학', '성적': [85, 90, 78, 92], '학년': 3}\n\n모든 키: ['이름', '나이', '전공', '성적', '학년']\n모든 값: ['김철수', 21, '컴퓨터과학', [85, 90, 78, 92], 3]\n\n학생 정보 출력:\n이름: 김철수\n나이: 21\n전공: 컴퓨터과학\n성적: [85, 90, 78, 92]\n학년: 3\n\n성적 삭제 후: {'이름': '김철수', '나이': 21, '전공': '컴퓨터과학', '학년': 3}",
    "order": 11
  },
  {
    "id": 12,
    "title": "Functions",
    "slug": "functions",
    "categoryId": 6,
    "description": "함수를 정의하고 활용하는 방법을 학습합니다",
    "code": "# 기본 함수 정의\ndef greet(name):\n    \"\"\"인사말을 출력하는 함수\"\"\"\n    return f\"안녕하세요, {name}님!\"\n\n# 함수 호출\nmessage = greet(\"김철수\")\nprint(message)\n\n# 매개변수가 여러 개인 함수\ndef calculate_area(width, height):\n    \"\"\"직사각형의 넓이를 계산\"\"\"\n    area = width * height\n    return area\n\nresult = calculate_area(5, 3)\nprint(f\"넓이: {result}\")\n\n# 기본값이 있는 매개변수\ndef introduce(name, age=25, city=\"서울\"):\n    \"\"\"자기소개 함수\"\"\"\n    return f\"저는 {name}이고, {age}살이며, {city}에 살고 있습니다.\"\n\nprint(introduce(\"이영희\"))\nprint(introduce(\"박민수\", 30))\nprint(introduce(\"최지원\", 28, \"부산\"))\n\n# 가변 인수 함수\ndef sum_numbers(*args):\n    \"\"\"여러 숫자의 합을 계산\"\"\"\n    total = 0\n    for num in args:\n        total += num\n    return total\n\nprint(f\"합계: {sum_numbers(1, 2, 3, 4, 5)}\")",
    "explanation": "함수는 특정 작업을 수행하는 재사용 가능한 코드 블록입니다. def 키워드로 정의하며, 매개변수를 받고 return으로 값을 반환할 수 있습니다. 기본값과 가변 인수를 사용할 수 있습니다.",
    "output": "안녕하세요, 김철수님!\n넓이: 15\n저는 이영희이고, 25살이며, 서울에 살고 있습니다.\n저는 박민수이고, 30살이며, 서울에 살고 있습니다.\n저는 최지원이고, 28살이며, 부산에 살고 있습니다.\n합계: 15",
    "order": 12
  },
  {
    "id": 13,
    "title": "Classes",
    "slug": "classes",
    "categoryId": 8,
    "description": "클래스와 객체지향 프로그래밍의 기초를 학습합니다",
    "code": "# 기본 클래스 정의\nclass Person:\n    \"\"\"사람을 나타내는 클래스\"\"\"\n    \n    def __init__(self, name, age):\n        \"\"\"생성자 메서드\"\"\"\n        self.name = name\n        self.age = age\n    \n    def introduce(self):\n        \"\"\"자기소개 메서드\"\"\"\n        return f\"안녕하세요, 저는 {self.name}이고 {self.age}살입니다.\"\n    \n    def have_birthday(self):\n        \"\"\"생일이 지나면 나이가 증가\"\"\"\n        self.age += 1\n        print(f\"{self.name}님, 생일 축하합니다! 이제 {self.age}살이 되었습니다.\")\n\n# 객체 생성\nperson1 = Person(\"김철수\", 25)\nperson2 = Person(\"이영희\", 30)\n\n# 메서드 호출\nprint(person1.introduce())\nprint(person2.introduce())\n\n# 속성 접근\nprint(f\"\\n{person1.name}의 나이: {person1.age}\")\n\n# 메서드 실행\nperson1.have_birthday()\nprint(person1.introduce())",
    "explanation": "클래스는 객체를 만들기 위한 템플릿입니다. __init__ 메서드는 객체 생성 시 호출되는 생성자이고, self는 객체 자신을 참조합니다. 클래스로부터 생성된 개별 객체를 인스턴스라고 합니다.",
    "output": "안녕하세요, 저는 김철수이고 25살입니다.\n안녕하세요, 저는 이영희이고 30살입니다.\n\n김철수의 나이: 25\n김철수님, 생일 축하합니다! 이제 26살이 되었습니다.\n안녕하세요, 저는 김철수이고 26살입니다.",
    "order": 13
  },
  {
    "id": 14,
    "title": "Modules",
    "slug": "modules",
    "categoryId": 10,
    "description": "모듈을 임포트하고 활용하는 방법을 배웁니다",
    "code": "# 표준 라이브러리 모듈 임포트\nimport math\nimport random\nfrom datetime import datetime, date\nimport os\n\n# math 모듈 사용\nprint(f\"원주율: {math.pi}\")\nprint(f\"4의 제곱근: {math.sqrt(4)}\")\nprint(f\"3의 2제곱: {math.pow(3, 2)}\")\n\n# random 모듈 사용\nprint(f\"\\n랜덤 숫자 (1-10): {random.randint(1, 10)}\")\ncolors = [\"빨강\", \"파랑\", \"노랑\", \"초록\"]\nprint(f\"랜덤 색상: {random.choice(colors)}\")\n\n# datetime 모듈 사용\nnow = datetime.now()\ntoday = date.today()\nprint(f\"\\n현재 시간: {now.strftime('%Y-%m-%d %H:%M:%S')}\")\nprint(f\"오늘 날짜: {today}\")\n\n# os 모듈 사용\nprint(f\"\\n현재 작업 디렉토리: {os.getcwd()}\")\nprint(f\"운영체제: {os.name}\")\n\n# 모듈의 함수를 별명으로 사용\nimport math as m\nprint(f\"\\n반지름 5인 원의 넓이: {m.pi * m.pow(5, 2)}\")",
    "explanation": "모듈은 관련된 함수, 클래스, 변수들을 하나의 파일로 묶은 것입니다. import 문으로 모듈을 가져와 사용할 수 있으며, from을 사용해 특정 함수만 가져오거나 as로 별명을 지정할 수 있습니다.",
    "output": "원주율: 3.141592653589793\n4의 제곱근: 2.0\n3의 2제곱: 9.0\n\n랜덤 숫자 (1-10): 7\n랜덤 색상: 파랑\n\n현재 시간: 2024-06-28 14:30:45\n오늘 날짜: 2024-06-28\n\n현재 작업 디렉토리: /home/user/python_project\n운영체제: posix\n\n반지름 5인 원의 넓이: 78.53981633974483",
    "order": 14
  },
  {
    "id": 15,
    "title": "Exception Handling",
    "slug": "exception-handling",
    "categoryId": 7,
    "description": "예외 처리로 견고한 프로그램을 작성하는 방법을 학습합니다",
    "code": "# 기본 예외 처리\ndef divide_numbers(a, b):\n    \"\"\"두 숫자를 나누는 함수\"\"\"\n    try:\n        result = a / b\n        print(f\"{a} ÷ {b} = {result}\")\n        return result\n    except ZeroDivisionError:\n        print(\"오류: 0으로 나눌 수 없습니다.\")\n        return None\n    except TypeError:\n        print(\"오류: 숫자가 아닌 값이 입력되었습니다.\")\n        return None\n\n# 예외 처리 테스트\ndivide_numbers(10, 2)\ndivide_numbers(10, 0)\ndivide_numbers(10, \"문자열\")\n\n# 여러 예외 처리\ndef safe_list_access(lst, index):\n    \"\"\"리스트의 안전한 접근\"\"\"\n    try:\n        value = lst[index]\n        print(f\"인덱스 {index}의 값: {value}\")\n        return value\n    except (IndexError, TypeError) as e:\n        print(f\"오류 발생: {e}\")\n        return None\n    finally:\n        print(\"함수 실행 완료\")\n\n# 테스트\nnumbers = [1, 2, 3, 4, 5]\nsafe_list_access(numbers, 2)\nsafe_list_access(numbers, 10)\nsafe_list_access(None, 0)",
    "explanation": "예외 처리는 프로그램 실행 중 발생할 수 있는 오류를 안전하게 처리하는 방법입니다. try-except 문으로 예외를 포착하고, finally 블록은 예외 발생 여부와 관계없이 항상 실행됩니다.",
    "output": "10 ÷ 2 = 5.0\n오류: 0으로 나눌 수 없습니다.\n오류: 숫자가 아닌 값이 입력되었습니다.\n인덱스 2의 값: 3\n함수 실행 완료\n오류 발생: list index out of range\n함수 실행 완료\n오류 발생: 'NoneType' object is not subscriptable\n함수 실행 완료",
    "order": 15
  },
  {
    "id": 16,
    "title": "File I/O",
    "slug": "file-io",
    "categoryId": 11,
    "description": "파일 읽기와 쓰기를 통한 데이터 영속화를 학습합니다",
    "code": "# 파일 쓰기\nwith open(\"sample.txt\", \"w\", encoding=\"utf-8\") as file:\n    file.write(\"안녕하세요!\\n\")\n    file.write(\"Python 파일 입출력 예제입니다.\\n\")\n    file.write(\"여러 줄의 텍스트를 저장합니다.\\n\")\n\nprint(\"파일이 생성되었습니다.\")\n\n# 파일 읽기\nprint(\"\\n파일 내용 읽기:\")\nwith open(\"sample.txt\", \"r\", encoding=\"utf-8\") as file:\n    content = file.read()\n    print(content)\n\n# 줄 단위로 읽기\nprint(\"줄 단위로 읽기:\")\nwith open(\"sample.txt\", \"r\", encoding=\"utf-8\") as file:\n    for line_num, line in enumerate(file, 1):\n        print(f\"{line_num}: {line.strip()}\")\n\n# 파일에 추가하기\nwith open(\"sample.txt\", \"a\", encoding=\"utf-8\") as file:\n    file.write(\"추가된 내용입니다.\\n\")\n\nprint(\"\\n파일에 내용을 추가했습니다.\")\n\n# 파일 존재 확인\nimport os\nif os.path.exists(\"sample.txt\"):\n    print(\"sample.txt 파일이 존재합니다.\")\n    print(f\"파일 크기: {os.path.getsize('sample.txt')} bytes\")",
    "explanation": "파일 입출력은 데이터를 영구적으로 저장하고 읽는 방법입니다. with 문을 사용하면 파일이 자동으로 닫히므로 안전합니다. 'r'(읽기), 'w'(쓰기), 'a'(추가) 모드가 있습니다.",
    "output": "파일이 생성되었습니다.\n\n파일 내용 읽기:\n안녕하세요!\nPython 파일 입출력 예제입니다.\n여러 줄의 텍스트를 저장합니다.\n\n줄 단위로 읽기:\n1: 안녕하세요!\n2: Python 파일 입출력 예제입니다.\n3: 여러 줄의 텍스트를 저장합니다.\n\n파일에 내용을 추가했습니다.\nsample.txt 파일이 존재합니다.\n파일 크기: 89 bytes",
    "order": 16
  },
  {
    "id": 17,
    "title": "Lambda Functions",
    "slug": "lambda-functions",
    "categoryId": 6,
    "description": "람다 함수와 함수형 프로그래밍 기초를 학습합니다",
    "code": "# 기본 람다 함수\nsquare = lambda x: x ** 2\nprint(f\"5의 제곱: {square(5)}\")\n\n# 두 매개변수를 가진 람다\nadd = lambda x, y: x + y\nprint(f\"3 + 7 = {add(3, 7)}\")\n\n# map() 함수와 람다\nnumbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x ** 2, numbers))\nprint(f\"\\n원본: {numbers}\")\nprint(f\"제곱: {squared}\")\n\n# filter() 함수와 람다\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))\nprint(f\"짝수만: {even_numbers}\")\n\n# sorted() 함수와 람다\nstudents = [\n    {\"이름\": \"김철수\", \"점수\": 85},\n    {\"이름\": \"이영희\", \"점수\": 92},\n    {\"이름\": \"박민수\", \"점수\": 78}\n]\n\n# 점수 순으로 정렬\nsorted_students = sorted(students, key=lambda student: student[\"점수\"], reverse=True)\nprint(\"\\n점수 순 정렬:\")\nfor student in sorted_students:\n    print(f\"{student['이름']}: {student['점수']}점\")\n\n# 리스트 컴프리헨션 (람다의 대안)\nsquared_comp = [x ** 2 for x in numbers]\nprint(f\"\\n컴프리헨션으로 제곱: {squared_comp}\")",
    "explanation": "람다 함수는 한 줄로 작성하는 익명 함수입니다. map(), filter(), sorted() 등의 함수와 함께 사용하여 함수형 프로그래밍 스타일로 코드를 작성할 수 있습니다. 간단한 연산에 유용합니다.",
    "output": "5의 제곱: 25\n3 + 7 = 10\n\n원본: [1, 2, 3, 4, 5]\n제곱: [1, 4, 9, 16, 25]\n짝수만: [2, 4]\n\n점수 순 정렬:\n이영희: 92점\n김철수: 85점\n박민수: 78점\n\n컴프리헨션으로 제곱: [1, 4, 9, 16, 25]",
    "order": 17
  },
  {
    "id": 18,
    "title": "List Comprehensions",
    "slug": "list-comprehensions",
    "categoryId": 9,
    "description": "리스트 컴프리헨션으로 효율적인 리스트 생성을 학습합니다",
    "code": "# 기본 리스트 컴프리헨션\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# 제곱 리스트\nsquares = [x ** 2 for x in numbers]\nprint(f\"제곱: {squares}\")\n\n# 조건부 컴프리헨션\neven_squares = [x ** 2 for x in numbers if x % 2 == 0]\nprint(f\"짝수의 제곱: {even_squares}\")\n\n# 문자열 처리\nwords = [\"python\", \"java\", \"javascript\", \"go\"]\nuppercase = [word.upper() for word in words]\nprint(f\"\\n대문자 변환: {uppercase}\")\n\n# 조건부 표현식\nresult = [\"짝수\" if x % 2 == 0 else \"홀수\" for x in range(1, 6)]\nprint(f\"홀짝 판별: {result}\")\n\n# 중첩 리스트 평탄화\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nflattened = [num for row in matrix for num in row]\nprint(f\"\\n원본 매트릭스: {matrix}\")\nprint(f\"평탄화: {flattened}\")\n\n# 딕셔너리 컴프리헨션\nsquare_dict = {x: x ** 2 for x in range(1, 6)}\nprint(f\"\\n제곱 딕셔너리: {square_dict}\")\n\n# 집합 컴프리헨션\nunique_lengths = {len(word) for word in words}\nprint(f\"단어 길이 집합: {unique_lengths}\")",
    "explanation": "컴프리헨션은 기존 iterable로부터 새로운 컬렉션을 간결하게 만드는 방법입니다. 리스트, 딕셔너리, 집합 컴프리헨션이 있으며, 조건문과 표현식을 사용하여 데이터를 변환하고 필터링할 수 있습니다.",
    "output": "제곱: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n짝수의 제곱: [4, 16, 36, 64, 100]\n\n대문자 변환: ['PYTHON', 'JAVA', 'JAVASCRIPT', 'GO']\n홀짝 판별: ['홀수', '짝수', '홀수', '짝수', '홀수']\n\n원본 매트릭스: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n평탄화: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n제곱 딕셔너리: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n단어 길이 집합: {2, 4, 6, 10}",
    "order": 18
  },
  {
    "id": 19,
    "title": "Generators",
    "slug": "generators",
    "categoryId": 9,
    "description": "제너레이터로 메모리 효율적인 프로그래밍을 학습합니다",
    "code": "# 기본 제너레이터 함수\ndef countdown(n):\n    \"\"\"카운트다운 제너레이터\"\"\"\n    while n > 0:\n        yield n\n        n -= 1\n    yield \"발사!\"\n\n# 제너레이터 사용\nprint(\"카운트다운:\")\nfor count in countdown(5):\n    print(count)\n\n# 피보나치 수열 제너레이터\ndef fibonacci(limit):\n    \"\"\"피보나치 수열 제너레이터\"\"\"\n    a, b = 0, 1\n    while a < limit:\n        yield a\n        a, b = b, a + b\n\nprint(\"\\n피보나치 수열 (100 미만):\")\nfib_numbers = list(fibonacci(100))\nprint(fib_numbers)\n\n# 제너레이터 표현식\nsquare_gen = (x ** 2 for x in range(1, 6))\nprint(\"\\n제곱 제너레이터:\")\nfor square in square_gen:\n    print(square)\n\n# 제너레이터의 메모리 효율성 비교\nimport sys\n\n# 리스트 컴프리헨션 (메모리 많이 사용)\nlarge_list = [x ** 2 for x in range(1000)]\nprint(f\"\\n리스트 크기: {sys.getsizeof(large_list)} bytes\")\n\n# 제너레이터 표현식 (메모리 적게 사용)\nlarge_gen = (x ** 2 for x in range(1000))\nprint(f\"제너레이터 크기: {sys.getsizeof(large_gen)} bytes\")\n\n# 제너레이터에서 특정 개수만 가져오기\nfrom itertools import islice\n\nprint(\"\\n처음 5개 피보나치 수:\")\nfirst_five = list(islice(fibonacci(1000), 5))\nprint(first_five)",
    "explanation": "제너레이터는 값을 필요할 때마다 생성하는 특별한 함수입니다. yield 키워드를 사용하며, 메모리를 효율적으로 사용할 수 있습니다. 큰 데이터셋을 다룰 때 특히 유용합니다.",
    "output": "카운트다운:\n5\n4\n3\n2\n1\n발사!\n\n피보나치 수열 (100 미만):\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n\n제곱 제너레이터:\n1\n4\n9\n16\n25\n\n리스트 크기: 8856 bytes\n제너레이터 크기: 112 bytes\n\n처음 5개 피보나치 수:\n[0, 1, 1, 2, 3]",
    "order": 19
  },
  {
    "id": 20,
    "title": "Decorators",
    "slug": "decorators",
    "categoryId": 9,
    "description": "데코레이터로 함수의 기능을 확장하는 방법을 학습합니다",
    "code": "import time\nimport functools\n\n# 기본 데코레이터\ndef timer(func):\n    \"\"\"함수 실행 시간을 측정하는 데코레이터\"\"\"\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"{func.__name__} 실행 시간: {end_time - start_time:.4f}초\")\n        return result\n    return wrapper\n\n# 로깅 데코레이터\ndef logger(func):\n    \"\"\"함수 호출을 로깅하는 데코레이터\"\"\"\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        print(f\"함수 '{func.__name__}' 호출됨\")\n        print(f\"인수: args={args}, kwargs={kwargs}\")\n        result = func(*args, **kwargs)\n        print(f\"반환값: {result}\")\n        return result\n    return wrapper\n\n# 데코레이터 적용\n@timer\n@logger\ndef calculate_sum(n):\n    \"\"\"1부터 n까지의 합을 계산\"\"\"\n    return sum(range(1, n + 1))\n\n# 함수 실행\nresult = calculate_sum(1000)\nprint(f\"\\n최종 결과: {result}\")\n\n# 매개변수가 있는 데코레이터\ndef repeat(times):\n    \"\"\"함수를 지정된 횟수만큼 반복 실행하는 데코레이터\"\"\"\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            for i in range(times):\n                print(f\"실행 {i + 1}회:\")\n                result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n\n@repeat(3)\ndef greet(name):\n    \"\"\"인사말 출력\"\"\"\n    message = f\"안녕하세요, {name}님!\"\n    print(message)\n    return message\n\nprint(\"\\n반복 실행:\")\ngreet(\"김철수\")",
    "explanation": "데코레이터는 함수나 클래스의 기능을 수정하거나 확장하는 특별한 함수입니다. @문법을 사용하여 적용하며, 로깅, 시간 측정, 권한 검사 등 공통 기능을 재사용할 수 있습니다.",
    "output": "함수 'calculate_sum' 호출됨\n인수: args=(1000,), kwargs={}\n반환값: 500500\ncalculate_sum 실행 시간: 0.0001초\n\n최종 결과: 500500\n\n반복 실행:\n실행 1회:\n안녕하세요, 김철수님!\n실행 2회:\n안녕하세요, 김철수님!\n실행 3회:\n안녕하세요, 김철수님!",
    "order": 20
  }
]