[
  {
    "id": 1,
    "title": "Hello World",
    "slug": "hello-world",
    "categoryId": 1,
    "description": "Our first program will print the classic \"hello world\" message.",
    "code": "print(\"hello world\")",
    "explanation": "To run the program, put the code in hello-world.py and use python.",
    "output": "hello world",
    "order": 1
  },
  {
    "id": 2,
    "title": "Literals",
    "slug": "literals",
    "categoryId": 1,
    "description": "Python has various value types including strings, integers, floats, booleans, etc.",
    "code": "# Strings, which can be added together with +.\nprint(\"python\" + \"rocks\")\n\n# Integers and floats.\nprint(\"1+1 =\", 1+1)\nprint(\"7.0/3.0 =\", 7.0/3.0)\n\n# Booleans, with boolean operators as you'd expect.\nprint(True and False)\nprint(True or False)\nprint(not True)",
    "explanation": "Here are the basic types in Python. Strings can be concatenated with +. Numbers support arithmetic operations. Booleans work with logical operators.",
    "output": "pythonrocks\n1+1 = 2\n7.0/3.0 = 2.3333333333333335\nFalse\nTrue\nFalse",
    "order": 2
  },
  {
    "id": 3,
    "title": "Variables",
    "slug": "variables",
    "categoryId": 1,
    "description": "In Python, variables are declared and assigned with =.",
    "code": "# Variables are declared and assigned in one line.\na = \"initial\"\nprint(a)\n\n# Variables can be reassigned.\nb = 1\nc = 2\nprint(b, c)\n\n# Python infers the type of initialized variables.\nd = True\nprint(d)",
    "explanation": "Python uses dynamic typing - you don't need to declare variable types explicitly. The type is inferred from the assigned value.",
    "output": "initial\n1 2\nTrue",
    "order": 3
  },
  {
    "id": 4,
    "title": "Constants",
    "slug": "constants",
    "categoryId": 1,
    "description": "Python supports constants by convention using UPPERCASE names.",
    "code": "# Constants are declared with UPPERCASE names by convention.\nPI = 3.14159\nMAX_SIZE = 100\nAPP_NAME = \"MyApp\"\n\nprint(\"PI:\", PI)\nprint(\"MAX_SIZE:\", MAX_SIZE)\nprint(\"APP_NAME:\", APP_NAME)\n\n# Python doesn't enforce immutability, it's just a naming convention.\n# For true constants, you can use the typing module:\nfrom typing import Final\n\nMAX_CONNECTIONS: Final = 10\nprint(\"MAX_CONNECTIONS:\", MAX_CONNECTIONS)",
    "explanation": "Python doesn't have built-in constants like some other languages. By convention, variables in ALL_CAPS are treated as constants. The typing.Final annotation can hint that a value shouldn't change.",
    "output": "PI: 3.14159\nMAX_SIZE: 100\nAPP_NAME: MyApp\nMAX_CONNECTIONS: 10",
    "order": 4
  },
  {
    "id": 5,
    "title": "For Loops",
    "slug": "for-loops",
    "categoryId": 1,
    "description": "for is Python's primary looping construct.",
    "code": "# The most basic type, with a single condition.\ni = 1\nprint(\"Basic while loop:\")\nwhile i <= 3:\n    print(i)\n    i += 1\n\n# A classic for loop.\nprint(\"\\nFor loop with range:\")\nfor j in range(1, 4):\n    print(j)\n\n# for without a condition will loop repeatedly\n# until you break out of the loop or return.\nprint(\"\\nInfinite loop with break:\")\nfor i in range(10):\n    print(\"loop\")\n    if i >= 2:\n        break\n\n# You can also continue to the next iteration.\nprint(\"\\nLoop with continue:\")\nfor n in range(6):\n    if n % 2 == 0:\n        continue\n    print(n)",
    "explanation": "Python's for loop is used to iterate over sequences. range() generates a sequence of numbers. break exits the loop, continue skips to the next iteration.",
    "output": "Basic while loop:\n1\n2\n3\n\nFor loop with range:\n1\n2\n3\n\nInfinite loop with break:\nloop\nloop\nloop\n\nLoop with continue:\n1\n3\n5",
    "order": 5
  },
  {
    "id": 6,
    "title": "If / Else",
    "slug": "if-else",
    "categoryId": 1,
    "description": "Branching with if and else in Python is straightforward.",
    "code": "# Here's a basic example.\nif 7 % 2 == 0:\n    print(\"7 is even\")\nelse:\n    print(\"7 is odd\")\n\n# You can have an if statement without an else.\nif 8 % 4 == 0:\n    print(\"8 is divisible by 4\")\n\n# A statement can be preceded by if;\n# a shorthand for an if statement.\nnum = 9\nprint(\"9 is odd\" if num % 2 == 1 else \"9 is even\")\n\n# elif allows for multiple conditions.\nscore = 85\nif score >= 90:\n    grade = \"A\"\nelif score >= 80:\n    grade = \"B\"\nelif score >= 70:\n    grade = \"C\"\nelse:\n    grade = \"F\"\nprint(f\"Grade: {grade}\")",
    "explanation": "Python uses if, elif, and else for conditional statements. The ternary operator (expression if condition else expression) provides a concise way to write simple conditionals.",
    "output": "7 is odd\n8 is divisible by 4\n9 is odd\nGrade: B",
    "order": 6
  },
  {
    "id": 7,
    "title": "Pattern Matching",
    "slug": "pattern-matching",
    "categoryId": 1,
    "description": "Python 3.10+ supports pattern matching with match/case statements.",
    "code": "# Basic pattern matching with match/case (Python 3.10+)\ndef describe_animal(animal):\n    match animal:\n        case \"dog\":\n            return \"loyal companion\"\n        case \"cat\":\n            return \"independent hunter\"\n        case \"bird\":\n            return \"flying friend\"\n        case _:\n            return \"unknown animal\"\n\nprint(describe_animal(\"dog\"))\nprint(describe_animal(\"fish\"))\n\n# Pattern matching with values\ndef check_number(x):\n    match x:\n        case 0:\n            return \"zero\"\n        case 1 | 2 | 3:\n            return \"small number\"\n        case n if n > 100:\n            return \"big number\"\n        case _:\n            return \"regular number\"\n\nprint(check_number(0))\nprint(check_number(2))\nprint(check_number(150))\nprint(check_number(42))\n\n# Pattern matching with data structures\ndef analyze_point(point):\n    match point:\n        case (0, 0):\n            return \"origin\"\n        case (0, y):\n            return f\"on y-axis at {y}\"\n        case (x, 0):\n            return f\"on x-axis at {x}\"\n        case (x, y):\n            return f\"point at ({x}, {y})\"\n\nprint(analyze_point((0, 0)))\nprint(analyze_point((0, 5)))\nprint(analyze_point((3, 4)))",
    "explanation": "Pattern matching with match/case statements was introduced in Python 3.10. It allows for more expressive conditional logic, especially when dealing with structured data. The underscore (_) acts as a wildcard that matches anything.",
    "output": "loyal companion\nunknown animal\nzero\nsmall number\nbig number\nregular number\norigin\non y-axis at 5\npoint at (3, 4)",
    "order": 7
  },
  {
    "id": 8,
    "title": "Lists",
    "slug": "lists",
    "categoryId": 1,
    "description": "Lists are Python's basic sequence type.",
    "code": "# Create an empty list\ns = []\nprint(\"emp:\", s)\n\n# Lists can hold any type\ns = [\"a\", \"b\", \"c\"]\nprint(\"set:\", s)\nprint(\"get:\", s[2])\nprint(\"len:\", len(s))\n\n# In addition to these basic operations, lists\n# support many more that make them useful for\n# implementing dynamic arrays.\ns.append(\"d\")\ns.append(\"e\")\ns.append(\"f\")\nprint(\"apd:\", s)\n\n# Lists can be copied\nc = s.copy()\nprint(\"cpy:\", c)\n\n# Get a slice with [low:high]\nl = s[2:5]\nprint(\"sl1:\", l)\n\n# This slices up to (but excluding) s[5]\nl = s[:5]\nprint(\"sl2:\", l)\n\n# And this slices up from (and including) s[2]\nl = s[2:]\nprint(\"sl3:\", l)\n\n# We can declare and initialize a variable for\n# list in a single line\nt = [\"g\", \"h\", \"i\"]\nprint(\"dcl:\", t)\n\n# Lists can be composed into multi-dimensional\n# data structures. The length of the inner lists\n# can vary, unlike arrays in some other languages.\ntwoD = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]\nprint(\"2d: \", twoD)",
    "explanation": "Lists in Python are ordered, mutable sequences that can hold items of any type. They support indexing, slicing, and many useful methods for manipulation.",
    "output": "emp: []\nset: ['a', 'b', 'c']\nget: c\nlen: 3\napd: ['a', 'b', 'c', 'd', 'e', 'f']\ncpy: ['a', 'b', 'c', 'd', 'e', 'f']\nsl1: ['c', 'd', 'e']\nsl2: ['a', 'b', 'c', 'd', 'e']\nsl3: ['c', 'd', 'e', 'f']\ndcl: ['g', 'h', 'i']\n2d:  [[1, 2, 3], [4, 5], [6, 7, 8, 9]]",
    "order": 8
  },
  {
    "id": 9,
    "title": "Tuples",
    "slug": "tuples",
    "categoryId": 1,
    "description": "Tuples are immutable sequences, useful for representing fixed collections of items.",
    "code": "# Create a tuple with 2 values\na = (\"apple\", \"banana\")\nprint(a)\n\n# Access tuple elements\nprint(\"First:\", a[0])\nprint(\"Second:\", a[1])\n\n# Tuples are immutable - you can't change them after creation\n# a[0] = \"orange\"  # This would cause an error\n\n# Get the length of a tuple\nprint(\"Length:\", len(a))\n\n# Tuple unpacking - assign tuple values to variables\nfruit1, fruit2 = a\nprint(\"Unpacked:\", fruit1, fruit2)\n\n# Single element tuple (note the comma)\nsingle = (\"only\",)\nprint(\"Single:\", single)\nprint(\"Type:\", type(single))\n\n# Without comma, it's just parentheses around a value\nnot_tuple = (\"only\")\nprint(\"Not tuple:\", not_tuple)\nprint(\"Type:\", type(not_tuple))\n\n# Empty tuple\nempty = ()\nprint(\"Empty:\", empty)\n\n# Tuples can contain different types\nmixed = (1, \"hello\", 3.14, True)\nprint(\"Mixed:\", mixed)\n\n# Nested tuples\nnested = ((1, 2), (3, 4), (5, 6))\nprint(\"Nested:\", nested)\nprint(\"Access nested:\", nested[1][0])",
    "explanation": "Tuples are ordered, immutable sequences. They're perfect for representing fixed collections like coordinates, RGB values, or function return values. Tuple unpacking is a powerful feature for assigning multiple variables at once.",
    "output": "('apple', 'banana')\nFirst: apple\nSecond: banana\nLength: 2\nUnpacked: apple banana\nSingle: ('only',)\nType: <class 'tuple'>\nNot tuple: only\nType: <class 'str'>\nEmpty: ()\nMixed: (1, 'hello', 3.14, True)\nNested: ((1, 2), (3, 4), (5, 6))\nAccess nested: 3",
    "order": 9
  },
  {
    "id": 10,
    "title": "List Slicing",
    "slug": "list-slicing",
    "categoryId": 1,
    "description": "Slicing allows you to extract portions of lists using [start:stop:step] syntax.",
    "code": "# Create a list to work with\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(\"Original:\", numbers)\n\n# Basic slicing [start:stop]\nprint(\"[2:5]:\", numbers[2:5])  # Elements 2, 3, 4\nprint(\"[1:7]:\", numbers[1:7])  # Elements 1-6\n\n# Omitting start or stop\nprint(\"[:4]:\", numbers[:4])    # From beginning to index 3\nprint(\"[6:]:\", numbers[6:])    # From index 6 to end\nprint(\"[:]:\", numbers[:])      # Entire list (copy)\n\n# Negative indices\nprint(\"[-3:]:\", numbers[-3:])  # Last 3 elements\nprint(\"[:-2]:\", numbers[:-2])  # All except last 2\nprint(\"[-5:-2]:\", numbers[-5:-2])  # From 5th last to 3rd last\n\n# Step parameter [start:stop:step]\nprint(\"[::2]:\", numbers[::2])   # Every 2nd element\nprint(\"[1::3]:\", numbers[1::3]) # Every 3rd element starting from index 1\nprint(\"[2:8:2]:\", numbers[2:8:2]) # Every 2nd element from index 2 to 7\n\n# Reverse slicing\nprint(\"[::-1]:\", numbers[::-1])  # Reverse the entire list\nprint(\"[8:2:-1]:\", numbers[8:2:-1])  # Reverse slice from 8 to 3\nprint(\"[7::-2]:\", numbers[7::-2])    # Every 2nd element in reverse from index 7\n\n# Slicing strings works the same way\ntext = \"Python Programming\"\nprint(\"\\nString slicing:\")\nprint(\"Original:\", text)\nprint(\"[0:6]:\", text[0:6])\nprint(\"[7:]:\", text[7:])\nprint(\"[::-1]:\", text[::-1])  # Reverse string\nprint(\"[::2]:\", text[::2])    # Every 2nd character",
    "explanation": "Slicing is a powerful feature that allows you to extract subsequences from lists, tuples, and strings. The syntax is [start:stop:step], where start is inclusive, stop is exclusive, and step determines the increment.",
    "output": "Original: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[2:5]: [2, 3, 4]\n[1:7]: [1, 2, 3, 4, 5, 6]\n[:4]: [0, 1, 2, 3]\n[6:]: [6, 7, 8, 9]\n[:]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[-3:]: [7, 8, 9]\n[:-2]: [0, 1, 2, 3, 4, 5, 6, 7]\n[-5:-2]: [5, 6, 7]\n[::2]: [0, 2, 4, 6, 8]\n[1::3]: [1, 4, 7]\n[2:8:2]: [2, 4, 6]\n[::-1]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n[8:2:-1]: [8, 7, 6, 5, 4, 3]\n[7::-2]: [7, 5, 3, 1]\n\nString slicing:\nOriginal: Python Programming\n[0:6]: Python\n[7:]: Programming\n[::-1]: gnimmargorP nohtyP\n[::2]: Pto rgamn",
    "order": 10
  },
  {
    "id": 11,
    "title": "Dictionaries",
    "slug": "dictionaries",
    "categoryId": 1,
    "description": "Dictionaries are Python's built-in mapping type.",
    "code": "# To create an empty dictionary, use dict().\nm = {}\n\n# Set key/value pairs using typical name[key] = val syntax.\nm[\"k1\"] = 7\nm[\"k2\"] = 13\n\nprint(\"map:\", m)\n\n# Printing a dictionary will show all of its key/value pairs.\nprint(\"len:\", len(m))\n\n# Get a value for a key with name[key].\nv1 = m[\"k1\"]\nprint(\"v1:\", v1)\n\n# The built-in delete() deletes key/value pairs from a map.\ndel m[\"k2\"]\nprint(\"map:\", m)\n\n# The optional second return value when getting a value\n# from a dictionary indicates if the key was present in the dictionary.\n# This can be used to disambiguate between missing keys and\n# keys with zero-values like 0 or \"\".\n_, prs = m.get(\"k2\", (None, False))\nprint(\"prs:\", \"k2\" in m)\n\n# You can also declare and initialize a new dictionary\n# in the same line.\nn = {\"foo\": 1, \"bar\": 2}\nprint(\"map:\", n)",
    "explanation": "Dictionaries store key-value pairs. Use square brackets to access values and the in operator to check for key existence. The get() method provides safe access with default values.",
    "output": "map: {'k1': 7, 'k2': 13}\nlen: 2\nv1: 7\nmap: {'k1': 7}\nprs: False\nmap: {'foo': 1, 'bar': 2}",
    "order": 11
  },
  {
    "id": 12,
    "title": "Functions",
    "slug": "functions",
    "categoryId": 1,
    "description": "Functions are central in Python.",
    "code": "# Here's a function that takes two ints and returns their sum as an int.\ndef plus(a, b):\n    # Python requires an explicit return; it won't automatically\n    # return the value of the last expression.\n    return a + b\n\n# Call a function just as you'd expect, with name(args).\nres = plus(1, 2)\nprint(\"1+2 =\", res)\n\nres = plus(3, 4)\nprint(\"3+4 =\", res)\n\n# Python supports multiple parameter types and default values.\ndef greet(name, greeting=\"Hello\"):\n    return f\"{greeting}, {name}!\"\n\nprint(greet(\"Alice\"))\nprint(greet(\"Bob\", \"Hi\"))\n\n# Functions can have multiple return values using tuples.\ndef vals():\n    return 3, 7\n\na, b = vals()\nprint(\"Multiple returns:\", a, b)",
    "explanation": "Functions in Python are defined with def. They can have default parameter values and return multiple values as tuples. Function calls use the familiar name(args) syntax.",
    "output": "1+2 = 3\n3+4 = 7\nHello, Alice!\nHi, Bob!\nMultiple returns: 3 7",
    "order": 12
  },
  {
    "id": 13,
    "title": "Multiple Return Values",
    "slug": "multiple-return-values",
    "categoryId": 1,
    "description": "Python supports multiple return values via tuples.",
    "code": "# Python functions can return multiple values using tuples.\n# This is often used to return both a result and an error value,\n# or multiple related values.\n\ndef vals():\n    return 3, 7\n\n# The 2 different return values from the function call\n# can be assigned to multiple variables.\na, b = vals()\nprint(a)\nprint(b)\n\n# If you only want a subset of the returned values,\n# use the blank identifier _.\n_, c = vals()\nprint(\"Only second value:\", c)\n\n# You can also return the tuple directly.\nresult = vals()\nprint(\"As tuple:\", result)\nprint(\"First element:\", result[0])\nprint(\"Second element:\", result[1])\n\n# Functions can return different types.\ndef mixed_returns():\n    return \"hello\", 42, True, [1, 2, 3]\n\ntext, number, flag, lst = mixed_returns()\nprint(f\"Mixed: {text}, {number}, {flag}, {lst}\")\n\n# Returning different numbers of values based on conditions.\ndef conditional_returns(include_extra=False):\n    if include_extra:\n        return \"result\", \"extra\", \"bonus\"\n    else:\n        return \"result\",  # Note the comma for single-element tuple\n\n# Handle variable return values\nresult1 = conditional_returns(False)\nresult2 = conditional_returns(True)\nprint(\"Conditional 1:\", result1)\nprint(\"Conditional 2:\", result2)",
    "explanation": "Python's tuple unpacking makes it easy to return and handle multiple values from functions. Use underscores to ignore unwanted return values, or access tuple elements by index.",
    "output": "3\n7\nOnly second value: 7\nAs tuple: (3, 7)\nFirst element: 3\nSecond element: 7\nMixed: hello, 42, True, [1, 2, 3]\nConditional 1: ('result',)\nConditional 2: ('result', 'extra', 'bonus')",
    "order": 13
  },
  {
    "id": 14,
    "title": "Variadic Functions",
    "slug": "variadic-functions",
    "categoryId": 1,
    "description": "Variadic functions can be called with any number of trailing arguments.",
    "code": "# Here's a function that will take an arbitrary number\n# of ints as arguments.\ndef sum_numbers(*nums):\n    print(f\"Numbers: {nums}\")\n    total = 0\n    for num in nums:\n        total += num\n    return total\n\n# Variadic functions can be called in the usual way\n# with individual arguments.\nresult = sum_numbers(1, 2)\nprint(f\"Sum of 1, 2: {result}\")\n\nresult = sum_numbers(1, 2, 3)\nprint(f\"Sum of 1, 2, 3: {result}\")\n\n# If you already have multiple args in a list,\n# apply them to a variadic function using the * operator.\nnums = [1, 2, 3, 4]\nresult = sum_numbers(*nums)\nprint(f\"Sum of list: {result}\")\n\n# **kwargs allows functions to accept keyword arguments.\ndef print_info(name, **kwargs):\n    print(f\"Name: {name}\")\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_info(\"Alice\", age=30, city=\"New York\", job=\"Engineer\")\n\n# Functions can combine regular args, *args, and **kwargs.\ndef flexible_function(required, *args, default=\"default\", **kwargs):\n    print(f\"Required: {required}\")\n    print(f\"Args: {args}\")\n    print(f\"Default: {default}\")\n    print(f\"Kwargs: {kwargs}\")\n\nflexible_function(\"must_have\", 1, 2, 3, default=\"custom\", extra=\"info\")",
    "explanation": "Use *args to accept any number of positional arguments and **kwargs for keyword arguments. The * operator can unpack sequences when calling functions.",
    "output": "Numbers: (1, 2)\nSum of 1, 2: 3\nNumbers: (1, 2, 3)\nSum of 1, 2, 3: 6\nNumbers: (1, 2, 3, 4)\nSum of list: 10\nName: Alice\nage: 30\ncity: New York\njob: Engineer\nRequired: must_have\nArgs: (1, 2, 3)\nDefault: custom\nKwargs: {'extra': 'info'}",
    "order": 14
  },
  {
    "id": 15,
    "title": "Closures",
    "slug": "closures",
    "categoryId": 1,
    "description": "Python supports anonymous functions and closures.",
    "code": "# Python supports closures, which are functions that\n# can access variables from an outer scope.\n\ndef int_seq():\n    i = 0\n    def next_val():\n        nonlocal i\n        i += 1\n        return i\n    return next_val\n\n# We call int_seq, assigning the result (a function)\n# to next_int. This function value captures its\n# own i value, which will be updated each time\n# we call next_int.\nnext_int = int_seq()\n\n# See the effect of the closure by calling next_int\n# a few times.\nprint(next_int())\nprint(next_int())\nprint(next_int())\n\n# To confirm that the state is unique to that\n# particular function, create and test a new one.\nnew_ints = int_seq()\nprint(\"New sequence:\", new_ints())\n\n# Closures can also be created with lambda functions.\ndef make_multiplier(factor):\n    return lambda x: x * factor\n\ndouble = make_multiplier(2)\ntriple = make_multiplier(3)\n\nprint(\"Double 5:\", double(5))\nprint(\"Triple 5:\", triple(5))\n\n# Another closure example - creating a counter\ndef make_counter(start=0):\n    count = start\n    def counter():\n        nonlocal count\n        count += 1\n        return count\n    return counter\n\ncounter1 = make_counter()\ncounter2 = make_counter(10)\n\nprint(\"Counter1:\", counter1(), counter1(), counter1())\nprint(\"Counter2:\", counter2(), counter2())",
    "explanation": "Closures allow inner functions to access variables from their outer scope. The nonlocal keyword lets you modify variables from the enclosing scope. Lambda functions can also create closures.",
    "output": "1\n2\n3\nNew sequence: 1\nDouble 5: 10\nTriple 5: 15\nCounter1: 1 2 3\nCounter2: 11 12",
    "order": 15
  }
]