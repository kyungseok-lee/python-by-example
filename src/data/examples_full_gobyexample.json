[
  {
    "id": 1,
    "title": "Hello World",
    "slug": "hello-world",
    "categoryId": 1,
    "description": "Our first program will print the classic \"hello world\" message.",
    "code": "print(\"hello world\")",
    "explanation": "To run the program, put the code in hello-world.py and use python.",
    "output": "hello world",
    "order": 1
  },
  {
    "id": 2,
    "title": "Literals",
    "slug": "literals",
    "categoryId": 1,
    "description": "Python has various value types including strings, integers, floats, booleans, etc.",
    "code": "# Strings, which can be added together with +.\nprint(\"python\" + \"rocks\")\n\n# Integers and floats.\nprint(\"1+1 =\", 1+1)\nprint(\"7.0/3.0 =\", 7.0/3.0)\n\n# Booleans, with boolean operators as you'd expect.\nprint(True and False)\nprint(True or False)\nprint(not True)",
    "explanation": "Here are the basic types in Python. Strings can be concatenated with +. Numbers support arithmetic operations. Booleans work with logical operators.",
    "output": "pythonrocks\n1+1 = 2\n7.0/3.0 = 2.3333333333333335\nFalse\nTrue\nFalse",
    "order": 2
  },
  {
    "id": 3,
    "title": "Variables",
    "slug": "variables",
    "categoryId": 1,
    "description": "In Python, variables are declared and assigned with =.",
    "code": "# Variables are declared and assigned in one line.\na = \"initial\"\nprint(a)\n\n# Variables can be reassigned.\nb = 1\nc = 2\nprint(b, c)\n\n# Python infers the type of initialized variables.\nd = True\nprint(d)",
    "explanation": "Python uses dynamic typing - you don't need to declare variable types explicitly. The type is inferred from the assigned value.",
    "output": "initial\n1 2\nTrue",
    "order": 3
  },
  {
    "id": 4,
    "title": "Constants",
    "slug": "constants",
    "categoryId": 1,
    "description": "Python supports constants by convention using UPPERCASE names.",
    "code": "# Constants are declared with UPPERCASE names by convention.\nPI = 3.14159\nMAX_SIZE = 100\nAPP_NAME = \"MyApp\"\n\nprint(\"PI:\", PI)\nprint(\"MAX_SIZE:\", MAX_SIZE)\nprint(\"APP_NAME:\", APP_NAME)\n\n# For true constants, you can use the typing module:\nfrom typing import Final\n\nMAX_CONNECTIONS: Final = 10\nprint(\"MAX_CONNECTIONS:\", MAX_CONNECTIONS)",
    "explanation": "Python doesn't have built-in constants. By convention, variables in ALL_CAPS are treated as constants. The typing.Final annotation can hint that a value shouldn't change.",
    "output": "PI: 3.14159\nMAX_SIZE: 100\nAPP_NAME: MyApp\nMAX_CONNECTIONS: 10",
    "order": 4
  },
  {
    "id": 5,
    "title": "For Loops",
    "slug": "for-loops",
    "categoryId": 1,
    "description": "for is Python's primary looping construct.",
    "code": "# The most basic type, with a single condition.\ni = 1\nwhile i <= 3:\n    print(i)\n    i += 1\n\n# A classic for loop.\nfor j in range(1, 4):\n    print(j)\n\n# for without a condition will loop repeatedly\n# until you break out of the loop or return.\nfor i in range(10):\n    print(\"loop\")\n    if i >= 2:\n        break\n\n# You can also continue to the next iteration.\nfor n in range(6):\n    if n % 2 == 0:\n        continue\n    print(n)",
    "explanation": "Python's for loop is used to iterate over sequences. range() generates a sequence of numbers. break exits the loop, continue skips to the next iteration.",
    "output": "1\n2\n3\n1\n2\n3\nloop\nloop\nloop\n1\n3\n5",
    "order": 5
  },
  {
    "id": 6,
    "title": "If / Else",
    "slug": "if-else",
    "categoryId": 1,
    "description": "Branching with if and else in Python is straightforward.",
    "code": "# Here's a basic example.\nif 7 % 2 == 0:\n    print(\"7 is even\")\nelse:\n    print(\"7 is odd\")\n\n# You can have an if statement without an else.\nif 8 % 4 == 0:\n    print(\"8 is divisible by 4\")\n\n# A ternary operator for concise conditionals.\nnum = 9\nprint(\"9 is odd\" if num % 2 == 1 else \"9 is even\")\n\n# elif allows for multiple conditions.\nscore = 85\nif score >= 90:\n    grade = \"A\"\nelif score >= 80:\n    grade = \"B\"\nelif score >= 70:\n    grade = \"C\"\nelse:\n    grade = \"F\"\nprint(f\"Grade: {grade}\")",
    "explanation": "Python uses if, elif, and else for conditional statements. The ternary operator (expression if condition else expression) provides a concise way to write simple conditionals.",
    "output": "7 is odd\n8 is divisible by 4\n9 is odd\nGrade: B",
    "order": 6
  },
  {
    "id": 7,
    "title": "Pattern Matching",
    "slug": "pattern-matching",
    "categoryId": 1,
    "description": "Python 3.10+ supports pattern matching with match/case statements.",
    "code": "# Basic pattern matching with match/case (Python 3.10+)\ndef describe_animal(animal):\n    match animal:\n        case \"dog\":\n            return \"loyal companion\"\n        case \"cat\":\n            return \"independent hunter\"\n        case \"bird\":\n            return \"flying friend\"\n        case _:\n            return \"unknown animal\"\n\nprint(describe_animal(\"dog\"))\nprint(describe_animal(\"fish\"))\n\n# Pattern matching with values\ndef check_number(x):\n    match x:\n        case 0:\n            return \"zero\"\n        case 1 | 2 | 3:\n            return \"small number\"\n        case n if n > 100:\n            return \"big number\"\n        case _:\n            return \"regular number\"\n\nprint(check_number(0))\nprint(check_number(2))\nprint(check_number(150))\n\n# Pattern matching with data structures\ndef analyze_point(point):\n    match point:\n        case (0, 0):\n            return \"origin\"\n        case (0, y):\n            return f\"on y-axis at {y}\"\n        case (x, 0):\n            return f\"on x-axis at {x}\"\n        case (x, y):\n            return f\"point at ({x}, {y})\"\n\nprint(analyze_point((0, 0)))\nprint(analyze_point((3, 4)))",
    "explanation": "Pattern matching with match/case statements was introduced in Python 3.10. It allows for more expressive conditional logic, especially when dealing with structured data.",
    "output": "loyal companion\nunknown animal\nzero\nsmall number\nbig number\norigin\npoint at (3, 4)",
    "order": 7
  },
  {
    "id": 8,
    "title": "Lists",
    "slug": "lists",
    "categoryId": 1,
    "description": "Lists are Python's basic sequence type.",
    "code": "# Create an empty list\ns = []\nprint(\"emp:\", s)\n\n# Lists can hold any type\ns = [\"a\", \"b\", \"c\"]\nprint(\"set:\", s)\nprint(\"get:\", s[2])\nprint(\"len:\", len(s))\n\n# Lists support many operations\ns.append(\"d\")\ns.append(\"e\")\ns.append(\"f\")\nprint(\"apd:\", s)\n\n# Lists can be copied\nc = s.copy()\nprint(\"cpy:\", c)\n\n# Get a slice with [low:high]\nl = s[2:5]\nprint(\"sl1:\", l)\n\n# Slice up to (but excluding) s[5]\nl = s[:5]\nprint(\"sl2:\", l)\n\n# Slice up from (and including) s[2]\nl = s[2:]\nprint(\"sl3:\", l)\n\n# Declare and initialize in a single line\nt = [\"g\", \"h\", \"i\"]\nprint(\"dcl:\", t)\n\n# Multi-dimensional lists\ntwoD = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]\nprint(\"2d:\", twoD)",
    "explanation": "Lists in Python are ordered, mutable sequences that can hold items of any type. They support indexing, slicing, and many useful methods for manipulation.",
    "output": "emp: []\nset: ['a', 'b', 'c']\nget: c\nlen: 3\napd: ['a', 'b', 'c', 'd', 'e', 'f']\ncpy: ['a', 'b', 'c', 'd', 'e', 'f']\nsl1: ['c', 'd', 'e']\nsl2: ['a', 'b', 'c', 'd', 'e']\nsl3: ['c', 'd', 'e', 'f']\ndcl: ['g', 'h', 'i']\n2d: [[1, 2, 3], [4, 5], [6, 7, 8, 9]]",
    "order": 8
  },
  {
    "id": 9,
    "title": "Tuples",
    "slug": "tuples",
    "categoryId": 1,
    "description": "Tuples are immutable sequences.",
    "code": "# Create a tuple with 2 values\na = (\"apple\", \"banana\")\nprint(a)\n\n# Access tuple elements\nprint(\"First:\", a[0])\nprint(\"Second:\", a[1])\n\n# Get the length of a tuple\nprint(\"Length:\", len(a))\n\n# Tuple unpacking - assign tuple values to variables\nfruit1, fruit2 = a\nprint(\"Unpacked:\", fruit1, fruit2)\n\n# Single element tuple (note the comma)\nsingle = (\"only\",)\nprint(\"Single:\", single)\n\n# Empty tuple\nempty = ()\nprint(\"Empty:\", empty)\n\n# Tuples can contain different types\nmixed = (1, \"hello\", 3.14, True)\nprint(\"Mixed:\", mixed)\n\n# Nested tuples\nnested = ((1, 2), (3, 4), (5, 6))\nprint(\"Nested:\", nested)",
    "explanation": "Tuples are ordered, immutable sequences. They're perfect for representing fixed collections like coordinates or function return values. Tuple unpacking is a powerful feature.",
    "output": "('apple', 'banana')\nFirst: apple\nSecond: banana\nLength: 2\nUnpacked: apple banana\nSingle: ('only',)\nEmpty: ()\nMixed: (1, 'hello', 3.14, True)\nNested: ((1, 2), (3, 4), (5, 6))",
    "order": 9
  },
  {
    "id": 10,
    "title": "List Slicing",
    "slug": "list-slicing",
    "categoryId": 1,
    "description": "Slicing allows you to extract portions of lists using [start:stop:step] syntax.",
    "code": "# Create a list to work with\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(\"Original:\", numbers)\n\n# Basic slicing [start:stop]\nprint(\"[2:5]:\", numbers[2:5])  # Elements 2, 3, 4\nprint(\"[1:7]:\", numbers[1:7])  # Elements 1-6\n\n# Omitting start or stop\nprint(\"[:4]:\", numbers[:4])    # From beginning to index 3\nprint(\"[6:]:\", numbers[6:])    # From index 6 to end\nprint(\"[:]:\", numbers[:])      # Entire list (copy)\n\n# Negative indices\nprint(\"[-3:]:\", numbers[-3:])  # Last 3 elements\nprint(\"[:-2]:\", numbers[:-2])  # All except last 2\n\n# Step parameter [start:stop:step]\nprint(\"[::2]:\", numbers[::2])   # Every 2nd element\nprint(\"[1::3]:\", numbers[1::3]) # Every 3rd element starting from index 1\n\n# Reverse slicing\nprint(\"[::-1]:\", numbers[::-1])  # Reverse the entire list",
    "explanation": "Slicing is a powerful feature that allows you to extract subsequences from lists, tuples, and strings. The syntax is [start:stop:step], where start is inclusive, stop is exclusive.",
    "output": "Original: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[2:5]: [2, 3, 4]\n[1:7]: [1, 2, 3, 4, 5, 6]\n[:4]: [0, 1, 2, 3]\n[6:]: [6, 7, 8, 9]\n[:]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[-3:]: [7, 8, 9]\n[:-2]: [0, 1, 2, 3, 4, 5, 6, 7]\n[::2]: [0, 2, 4, 6, 8]\n[1::3]: [1, 4, 7]\n[::-1]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]",
    "order": 10
  },
  {
    "id": 11,
    "title": "Dictionaries",
    "slug": "dictionaries",
    "categoryId": 1,
    "description": "Dictionaries are Python's built-in mapping type.",
    "code": "# To create an empty dictionary, use {}.\nm = {}\n\n# Set key/value pairs using typical name[key] = val syntax.\nm[\"k1\"] = 7\nm[\"k2\"] = 13\n\nprint(\"map:\", m)\n\n# Printing a dictionary will show all of its key/value pairs.\nprint(\"len:\", len(m))\n\n# Get a value for a key with name[key].\nv1 = m[\"k1\"]\nprint(\"v1:\", v1)\n\n# Delete key/value pairs from a dictionary.\ndel m[\"k2\"]\nprint(\"map:\", m)\n\n# Check if a key is present in the dictionary.\nprint(\"prs:\", \"k2\" in m)\n\n# You can also declare and initialize a new dictionary\n# in the same line.\nn = {\"foo\": 1, \"bar\": 2}\nprint(\"map:\", n)",
    "explanation": "Dictionaries store key-value pairs. Use square brackets to access values and the in operator to check for key existence.",
    "output": "map: {'k1': 7, 'k2': 13}\nlen: 2\nv1: 7\nmap: {'k1': 7}\nprs: False\nmap: {'foo': 1, 'bar': 2}",
    "order": 11
  },
  {
    "id": 12,
    "title": "Functions",
    "slug": "functions",
    "categoryId": 1,
    "description": "Functions are central in Python.",
    "code": "# Here's a function that takes two ints and returns their sum as an int.\ndef plus(a, b):\n    # Python requires an explicit return; it won't automatically\n    # return the value of the last expression.\n    return a + b\n\n# Call a function just as you'd expect, with name(args).\nres = plus(1, 2)\nprint(\"1+2 =\", res)\n\nres = plus(3, 4)\nprint(\"3+4 =\", res)\n\n# Functions can have default parameter values.\ndef greet(name, greeting=\"Hello\"):\n    return f\"{greeting}, {name}!\"\n\nprint(greet(\"Alice\"))\nprint(greet(\"Bob\", \"Hi\"))",
    "explanation": "Functions in Python are defined with def. They can have default parameter values and must use explicit return statements.",
    "output": "1+2 = 3\n3+4 = 7\nHello, Alice!\nHi, Bob!",
    "order": 12
  },
  {
    "id": 13,
    "title": "Multiple Return Values",
    "slug": "multiple-return-values",
    "categoryId": 1,
    "description": "Python supports multiple return values via tuples.",
    "code": "# Python functions can return multiple values using tuples.\ndef vals():\n    return 3, 7\n\n# The 2 different return values from the function call\n# can be assigned to multiple variables.\na, b = vals()\nprint(a)\nprint(b)\n\n# If you only want a subset of the returned values,\n# use the blank identifier _.\n_, c = vals()\nprint(\"Only second value:\", c)\n\n# You can also return the tuple directly.\nresult = vals()\nprint(\"As tuple:\", result)",
    "explanation": "Python's tuple unpacking makes it easy to return and handle multiple values from functions. Use underscores to ignore unwanted return values.",
    "output": "3\n7\nOnly second value: 7\nAs tuple: (3, 7)",
    "order": 13
  },
  {
    "id": 14,
    "title": "Variadic Functions",
    "slug": "variadic-functions",
    "categoryId": 1,
    "description": "Variadic functions can be called with any number of trailing arguments.",
    "code": "# Here's a function that will take an arbitrary number\n# of arguments.\ndef sum_numbers(*nums):\n    print(f\"Numbers: {nums}\")\n    total = 0\n    for num in nums:\n        total += num\n    return total\n\n# Variadic functions can be called in the usual way\n# with individual arguments.\nresult = sum_numbers(1, 2)\nprint(f\"Sum: {result}\")\n\nresult = sum_numbers(1, 2, 3)\nprint(f\"Sum: {result}\")\n\n# If you already have multiple args in a list,\n# apply them to a variadic function using *.\nnums = [1, 2, 3, 4]\nresult = sum_numbers(*nums)\nprint(f\"Sum of list: {result}\")\n\n# **kwargs allows functions to accept keyword arguments.\ndef print_info(name, **kwargs):\n    print(f\"Name: {name}\")\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_info(\"Alice\", age=30, city=\"New York\")",
    "explanation": "Use *args to accept any number of positional arguments and **kwargs for keyword arguments. The * operator can unpack sequences when calling functions.",
    "output": "Numbers: (1, 2)\nSum: 3\nNumbers: (1, 2, 3)\nSum: 6\nNumbers: (1, 2, 3, 4)\nSum of list: 10\nName: Alice\nage: 30\ncity: New York",
    "order": 14
  },
  {
    "id": 15,
    "title": "Closures",
    "slug": "closures",
    "categoryId": 1,
    "description": "Python supports closures.",
    "code": "# Python supports closures, which are functions that\n# can access variables from an outer scope.\n\ndef int_seq():\n    i = 0\n    def next_val():\n        nonlocal i\n        i += 1\n        return i\n    return next_val\n\n# We call int_seq, assigning the result (a function)\n# to next_int. This function value captures its\n# own i value, which will be updated each time\n# we call next_int.\nnext_int = int_seq()\n\n# See the effect of the closure by calling next_int\n# a few times.\nprint(next_int())\nprint(next_int())\nprint(next_int())\n\n# To confirm that the state is unique to that\n# particular function, create and test a new one.\nnew_ints = int_seq()\nprint(\"New sequence:\", new_ints())",
    "explanation": "Closures allow inner functions to access variables from their outer scope. The nonlocal keyword lets you modify variables from the enclosing scope.",
    "output": "1\n2\n3\nNew sequence: 1",
    "order": 15
  }
]