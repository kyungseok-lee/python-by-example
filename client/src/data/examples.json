[
  {
    "id": 1,
    "slug": "hello-world",
    "title": "Hello World",
    "titleKo": "헬로 월드",
    "description": "첫 번째 파이썬 프로그램으로 기본적인 출력을 배웁니다.",
    "code": "# 기본적인 Hello World 프로그램\nprint(\"Hello, World!\")\n\n# 여러 줄 출력\nprint(\"파이썬으로\")\nprint(\"프로그래밍하기\")\n\n# 한 줄에 여러 값 출력\nprint(\"Hello\", \"Python\", \"World\")",
    "explanation": "첫 번째 프로그램은 전통적인 \"hello world\" 메시지를 출력합니다. 파이썬의 가장 기본적인 출력 함수인 print()를 사용합니다.\n\nprint() 함수는 파이썬에서 가장 기본적이고 중요한 내장 함수 중 하나입니다. 이 함수는 괄호 안에 있는 내용을 화면에 출력하고, 자동으로 줄바꿈을 추가합니다.\n\n문자열은 큰따옴표(\") 또는 작은따옴표(')로 감싸서 표현할 수 있습니다.",
    "additionalExamples": [
      {
        "title": "변수와 문자열",
        "code": "# 변수를 사용한 출력\nname = \"파이썬\"\nprint(f\"안녕하세요, {name}!\")"
      },
      {
        "title": "숫자와 계산",
        "code": "# 간단한 계산 결과 출력\nprint(\"2 + 3 =\", 2 + 3)\nprint(\"10 * 5 =\", 10 * 5)"
      }
    ],
    "categoryId": 1,
    "order": 1,
    "prevSlug": null,
    "nextSlug": "variables"
  },
  {
    "id": 2,
    "slug": "variables",
    "title": "Variables",
    "titleKo": "변수",
    "description": "파이썬에서 변수를 정의하고 사용하는 방법을 학습합니다.",
    "code": "# 변수 정의\nmessage = \"안녕하세요!\"\nage = 25\nheight = 175.5\nis_student = True\n\n# 변수 출력\nprint(\"메시지:\", message)\nprint(\"나이:\", age)\nprint(\"키:\", height)\nprint(\"학생 여부:\", is_student)\n\n# 변수 값 변경\nage = age + 1\nprint(\"다음 해 나이:\", age)\n\n# 여러 변수 동시 할당\nx, y, z = 1, 2, 3\nprint(f\"x={x}, y={y}, z={z}\")",
    "explanation": "변수는 데이터를 저장하는 컨테이너입니다. 파이썬에서는 변수 타입을 명시적으로 선언할 필요가 없습니다.\n\n파이썬의 주요 데이터 타입:\n- 정수 (int): 123, -456\n- 실수 (float): 3.14, -2.5\n- 문자열 (str): \"안녕하세요\", 'Hello'\n- 불린 (bool): True, False\n\n변수명 규칙:\n- 문자, 숫자, 밑줄(_)만 사용 가능\n- 숫자로 시작할 수 없음\n- 대소문자 구분\n- 예약어 사용 불가",
    "additionalExamples": [
      {
        "title": "변수명 규칙",
        "code": "# 올바른 변수명\nuser_name = \"김철수\"\nage2 = 30\n_private_var = \"숨겨진 값\"\n\n# 잘못된 변수명 (사용하지 마세요)\n# 2age = 30  # 숫자로 시작\n# user-name = \"김철수\"  # 하이픈 사용\n# class = \"A\"  # 예약어 사용"
      }
    ],
    "categoryId": 1,
    "order": 2,
    "prevSlug": "hello-world",
    "nextSlug": "data-types"
  },
  {
    "id": 3,
    "slug": "data-types",
    "title": "Data Types",
    "titleKo": "데이터 타입",
    "description": "파이썬의 기본 데이터 타입들을 알아봅니다.",
    "code": "# 정수 (int)\nnumber = 42\nprint(f\"정수: {number}, 타입: {type(number)}\")\n\n# 실수 (float)\npi = 3.14159\nprint(f\"실수: {pi}, 타입: {type(pi)}\")\n\n# 문자열 (str)\nname = \"파이썬\"\nprint(f\"문자열: {name}, 타입: {type(name)}\")\n\n# 불린 (bool)\nis_true = True\nis_false = False\nprint(f\"불린값: {is_true}, {is_false}\")\n\n# 타입 변환\nstr_number = \"123\"\nint_number = int(str_number)\nfloat_number = float(str_number)\nprint(f\"문자열 '123'을 정수로: {int_number}\")\nprint(f\"문자열 '123'을 실수로: {float_number}\")",
    "explanation": "파이썬은 동적 타입 언어로, 변수의 타입을 자동으로 결정합니다.\n\n기본 데이터 타입:\n- int: 정수 (-2, -1, 0, 1, 2, ...)\n- float: 실수 (3.14, -2.5, 0.0)\n- str: 문자열 (\"Hello\", 'World')\n- bool: 불린값 (True, False)\n\ntype() 함수로 변수의 타입을 확인할 수 있습니다.\n타입 변환 함수: int(), float(), str(), bool()",
    "additionalExamples": [
      {
        "title": "문자열 연산",
        "code": "# 문자열 결합\nfirst_name = \"김\"\nlast_name = \"철수\"\nfull_name = first_name + last_name\nprint(\"이름:\", full_name)\n\n# 문자열 반복\nprint(\"하\" * 3)  # 하하하"
      }
    ],
    "categoryId": 1,
    "order": 3,
    "prevSlug": "variables",
    "nextSlug": "if-else"
  },
  {
    "id": 4,
    "slug": "if-else",
    "title": "If/Else",
    "titleKo": "조건문",
    "description": "조건에 따라 다른 코드를 실행하는 방법을 배웁니다.",
    "code": "# 기본 if 문\nage = 18\n\nif age >= 18:\n    print(\"성인입니다.\")\nelse:\n    print(\"미성년자입니다.\")\n\n# elif 사용\nscore = 85\n\nif score >= 90:\n    grade = \"A\"\nelif score >= 80:\n    grade = \"B\"\nelif score >= 70:\n    grade = \"C\"\nelse:\n    grade = \"F\"\n\nprint(f\"점수: {score}, 등급: {grade}\")\n\n# 중첩 조건문\nweather = \"비\"\ntemperature = 15\n\nif weather == \"비\":\n    if temperature < 10:\n        print(\"우산과 따뜻한 옷을 준비하세요.\")\n    else:\n        print(\"우산을 준비하세요.\")\nelse:\n    print(\"좋은 날씨네요!\")",
    "explanation": "조건문은 특정 조건이 참(True)인지 거짓(False)인지에 따라 다른 코드를 실행합니다.\n\n파이썬의 조건문 구조:\n- if: 조건이 참일 때 실행\n- elif: 이전 조건이 거짓이고 새 조건이 참일 때 실행\n- else: 모든 조건이 거짓일 때 실행\n\n비교 연산자:\n- == (같음), != (다름)\n- < (작음), > (큼)\n- <= (작거나 같음), >= (크거나 같음)\n\n논리 연산자:\n- and (그리고), or (또는), not (아님)",
    "additionalExamples": [
      {
        "title": "논리 연산자",
        "code": "# and, or, not 사용\nage = 20\nhas_license = True\n\nif age >= 18 and has_license:\n    print(\"운전할 수 있습니다.\")\n\nif age < 18 or not has_license:\n    print(\"운전할 수 없습니다.\")"
      }
    ],
    "categoryId": 2,
    "order": 1,
    "prevSlug": "data-types",
    "nextSlug": "for-loops"
  },
  {
    "id": 5,
    "slug": "for-loops",
    "title": "For Loops",
    "titleKo": "for 반복문",
    "description": "for 문을 사용하여 반복 작업을 수행하는 방법을 학습합니다.",
    "code": "# 기본 for 문\nfruits = [\"사과\", \"바나나\", \"오렌지\"]\nfor fruit in fruits:\n    print(f\"과일: {fruit}\")\n\n# range() 함수 사용\nprint(\"\\n1부터 5까지:\")\nfor i in range(1, 6):\n    print(i)\n\n# enumerate() 함수로 인덱스와 값 함께 사용\nprint(\"\\n인덱스와 함께:\")\nfor index, fruit in enumerate(fruits):\n    print(f\"{index}: {fruit}\")\n\n# 중첩 반복문\nprint(\"\\n구구단 2단:\")\nfor i in range(1, 10):\n    result = 2 * i\n    print(f\"2 x {i} = {result}\")\n\n# 문자열 반복\nword = \"Python\"\nfor char in word:\n    print(char, end=\" \")\nprint()  # 줄바꿈",
    "explanation": "for 문은 시퀀스(리스트, 문자열, 범위 등)의 각 요소에 대해 반복적으로 코드를 실행합니다.\n\n주요 사용법:\n- 리스트/튜플 반복: for item in list\n- 범위 반복: for i in range(start, stop)\n- 문자열 반복: for char in string\n- enumerate(): 인덱스와 값을 함께 반복\n\nrange() 함수:\n- range(n): 0부터 n-1까지\n- range(start, stop): start부터 stop-1까지\n- range(start, stop, step): 단계별 증가",
    "additionalExamples": [
      {
        "title": "리스트 컴프리헨션",
        "code": "# 일반적인 for 문\nsquares = []\nfor x in range(5):\n    squares.append(x**2)\nprint(\"제곱수:\", squares)\n\n# 리스트 컴프리헨션으로 간단하게\nsquares_comp = [x**2 for x in range(5)]\nprint(\"컴프리헨션:\", squares_comp)"
      }
    ],
    "categoryId": 2,
    "order": 2,
    "prevSlug": "if-else",
    "nextSlug": "while-loops"
  },
  {
    "id": 6,
    "slug": "while-loops",
    "title": "While Loops",
    "titleKo": "while 반복문",
    "description": "while 문을 사용하여 조건이 참인 동안 반복하는 방법을 학습합니다.",
    "code": "# 기본 while 문\ncount = 0\nwhile count < 5:\n    print(f\"카운트: {count}\")\n    count += 1\n\n# 사용자 입력 받기 (시뮬레이션)\nprint(\"\\n숫자 맞추기 게임:\")\nsecret_number = 7\nguess = 0\nattempts = 0\n\n# 실제로는 input()을 사용하지만, 여기서는 시뮬레이션\nguesses = [3, 5, 7]  # 사용자가 입력할 숫자들\nguess_index = 0\n\nwhile guess != secret_number and guess_index < len(guesses):\n    guess = guesses[guess_index]\n    attempts += 1\n    \n    if guess < secret_number:\n        print(f\"추측 {guess}: 너무 작습니다!\")\n    elif guess > secret_number:\n        print(f\"추측 {guess}: 너무 큽니다!\")\n    else:\n        print(f\"정답! {attempts}번 만에 맞췄습니다.\")\n    \n    guess_index += 1\n\n# break와 continue\nprint(\"\\nbreak 예제:\")\ni = 0\nwhile True:\n    if i >= 3:\n        break\n    print(f\"i = {i}\")\n    i += 1",
    "explanation": "while 문은 주어진 조건이 참(True)인 동안 코드 블록을 반복 실행합니다.\n\n기본 구조:\nwhile 조건:\n    실행할 코드\n\n주의사항:\n- 무한 루프를 피하기 위해 조건이 언젠가 거짓이 되도록 해야 합니다\n- 루프 내에서 조건에 영향을 주는 변수를 수정해야 합니다\n\n제어문:\n- break: 루프를 즉시 종료\n- continue: 현재 반복을 건너뛰고 다음 반복으로\n- while True: 무한 루프 (break로 탈출)",
    "additionalExamples": [
      {
        "title": "continue 사용",
        "code": "# continue로 홀수만 출력\nn = 0\nwhile n < 10:\n    n += 1\n    if n % 2 == 0:  # 짝수면 건너뛰기\n        continue\n    print(f\"홀수: {n}\")"
      }
    ],
    "categoryId": 2,
    "order": 3,
    "prevSlug": "for-loops",
    "nextSlug": "lists"
  },
  {
    "id": 7,
    "slug": "lists",
    "title": "Lists",
    "titleKo": "리스트",
    "description": "파이썬의 가장 유용한 자료구조인 리스트를 학습합니다.",
    "code": "# 리스트 생성\nfruits = [\"사과\", \"바나나\", \"오렌지\"]\nnumbers = [1, 2, 3, 4, 5]\nmixed = [\"안녕\", 42, True, 3.14]\n\nprint(\"과일:\", fruits)\nprint(\"숫자:\", numbers)\n\n# 리스트 접근\nprint(\"첫 번째 과일:\", fruits[0])\nprint(\"마지막 과일:\", fruits[-1])\n\n# 리스트 수정\nfruits[1] = \"딸기\"\nprint(\"수정된 과일:\", fruits)\n\n# 리스트에 요소 추가\nfruits.append(\"포도\")\nprint(\"추가 후:\", fruits)\n\n# 리스트에서 요소 제거\nfruits.remove(\"사과\")\nprint(\"제거 후:\", fruits)\n\n# 리스트 슬라이싱\nnumbers = [0, 1, 2, 3, 4, 5]\nprint(\"처음 3개:\", numbers[:3])\nprint(\"마지막 3개:\", numbers[-3:])\nprint(\"중간 부분:\", numbers[2:5])\n\n# 리스트 정보\nprint(\"리스트 길이:\", len(fruits))\nprint(\"최대값:\", max(numbers))\nprint(\"최소값:\", min(numbers))",
    "explanation": "리스트는 여러 개의 값을 순서대로 저장하는 자료구조입니다. 대괄호([])를 사용하여 생성합니다.\n\n주요 특징:\n- 순서가 있음 (인덱스로 접근 가능)\n- 변경 가능 (mutable)\n- 서로 다른 타입의 데이터 저장 가능\n- 중복 값 허용\n\n주요 메서드:\n- append(): 끝에 요소 추가\n- remove(): 특정 값 제거\n- pop(): 마지막 요소 제거 및 반환\n- insert(): 특정 위치에 요소 삽입\n- len(): 리스트 길이 반환\n\n슬라이싱: list[start:end:step]",
    "additionalExamples": [
      {
        "title": "리스트 정렬과 검색",
        "code": "# 리스트 정렬\nnumbers = [3, 1, 4, 1, 5, 9, 2]\nprint(\"원본:\", numbers)\n\nsorted_nums = sorted(numbers)  # 새 리스트 반환\nprint(\"정렬된 새 리스트:\", sorted_nums)\n\nnumbers.sort()  # 원본 리스트 수정\nprint(\"원본 정렬:\", numbers)\n\n# 요소 검색\nif 5 in numbers:\n    print(\"5가 리스트에 있습니다.\")\n    print(\"5의 인덱스:\", numbers.index(5))"
      }
    ],
    "categoryId": 3,
    "order": 1,
    "prevSlug": "while-loops",
    "nextSlug": "dictionaries"
  },
  {
    "id": 8,
    "slug": "dictionaries",
    "title": "Dictionaries",
    "titleKo": "딕셔너리",
    "description": "키-값 쌍으로 데이터를 저장하는 딕셔너리를 학습합니다.",
    "code": "# 딕셔너리 생성\nstudent = {\n    \"이름\": \"김철수\",\n    \"나이\": 20,\n    \"전공\": \"컴퓨터과학\",\n    \"성적\": [90, 85, 92]\n}\n\n# 딕셔너리 접근\nprint(\"학생 이름:\", student[\"이름\"])\nprint(\"학생 나이:\", student[\"나이\"])\n\n# get() 메서드 사용 (안전한 접근)\nprint(\"전화번호:\", student.get(\"전화번호\", \"없음\"))\n\n# 딕셔너리 수정\nstudent[\"나이\"] = 21\nstudent[\"학년\"] = 3\nprint(\"수정된 정보:\", student)\n\n# 딕셔너리 순회\nprint(\"\\n모든 정보:\")\nfor key, value in student.items():\n    print(f\"{key}: {value}\")\n\n# 키와 값 확인\nprint(\"\\n모든 키:\", list(student.keys()))\nprint(\"모든 값:\", list(student.values()))\n\n# 중첩 딕셔너리\nclassroom = {\n    \"학생1\": {\"이름\": \"김철수\", \"점수\": 90},\n    \"학생2\": {\"이름\": \"이영희\", \"점수\": 95}\n}\nprint(\"\\n교실 정보:\", classroom[\"학생1\"][\"이름\"])",
    "explanation": "딕셔너리는 키(key)와 값(value)의 쌍으로 데이터를 저장하는 자료구조입니다.\n\n주요 특징:\n- 키-값 쌍으로 구성\n- 키는 고유해야 함 (중복 불가)\n- 값은 중복 가능\n- 순서가 있음 (Python 3.7+)\n- 변경 가능 (mutable)\n\n주요 메서드:\n- get(key, default): 안전한 값 접근\n- keys(): 모든 키 반환\n- values(): 모든 값 반환\n- items(): 키-값 쌍 반환\n- pop(key): 키-값 쌍 제거 및 값 반환\n\n사용 사례: 설정 정보, 데이터베이스 레코드, JSON 데이터 등",
    "additionalExamples": [
      {
        "title": "딕셔너리 합치기",
        "code": "# 딕셔너리 합치기\ninfo1 = {\"이름\": \"김철수\", \"나이\": 20}\ninfo2 = {\"전공\": \"컴퓨터과학\", \"학년\": 3}\n\n# update() 메서드\ninfo1.update(info2)\nprint(\"합쳐진 딕셔너리:\", info1)\n\n# ** 연산자 (Python 3.5+)\ncombined = {**info1, **info2}\nprint(\"새로운 딕셔너리:\", combined)"
      }
    ],
    "categoryId": 3,
    "order": 2,
    "prevSlug": "lists",
    "nextSlug": "tuples"
  },
  {
    "id": 9,
    "slug": "tuples",
    "title": "Tuples",
    "titleKo": "튜플",
    "description": "변경할 수 없는 순서가 있는 자료구조인 튜플을 학습합니다.",
    "code": "# 튜플 생성\ncoordinates = (3, 4)\ncolors = (\"빨강\", \"초록\", \"파랑\")\nmixed_tuple = (\"안녕\", 42, True)\n\nprint(\"좌표:\", coordinates)\nprint(\"색상:\", colors)\n\n# 튜플 접근 (리스트와 동일)\nprint(\"첫 번째 색상:\", colors[0])\nprint(\"마지막 색상:\", colors[-1])\n\n# 튜플 언패킹\nx, y = coordinates\nprint(f\"x좌표: {x}, y좌표: {y}\")\n\n# 여러 변수에 동시 할당\nname, age, is_student = (\"김철수\", 20, True)\nprint(f\"이름: {name}, 나이: {age}, 학생: {is_student}\")\n\n# 튜플의 유용한 활용\n# 함수에서 여러 값 반환\ndef get_name_age():\n    return \"이영희\", 22\n\nstudent_name, student_age = get_name_age()\nprint(f\"학생: {student_name}, 나이: {student_age}\")\n\n# 튜플 메서드\nnumbers = (1, 2, 3, 2, 4, 2)\nprint(\"2의 개수:\", numbers.count(2))\nprint(\"2의 첫 번째 인덱스:\", numbers.index(2))\nprint(\"튜플 길이:\", len(numbers))",
    "explanation": "튜플은 순서가 있는 불변(immutable) 자료구조입니다. 리스트와 비슷하지만 생성 후 수정할 수 없습니다.\n\n주요 특징:\n- 순서가 있음\n- 불변 (immutable) - 생성 후 수정 불가\n- 중복 값 허용\n- 소괄호 () 사용 (생략 가능)\n- 해시 가능 (딕셔너리 키로 사용 가능)\n\n사용 사례:\n- 좌표, 날짜, 시간 등 고정 데이터\n- 함수에서 여러 값 반환\n- 딕셔너리의 키\n- 변경되면 안 되는 설정값\n\n튜플 언패킹: 여러 변수에 동시 할당",
    "additionalExamples": [
      {
        "title": "튜플과 리스트 변환",
        "code": "# 리스트를 튜플로\nlist_data = [1, 2, 3, 4]\ntuple_data = tuple(list_data)\nprint(\"튜플로 변환:\", tuple_data)\n\n# 튜플을 리스트로\nlist_from_tuple = list(tuple_data)\nprint(\"리스트로 변환:\", list_from_tuple)\n\n# 튜플 정렬 (새 리스트 반환)\nsorted_tuple = tuple(sorted((3, 1, 4, 1, 5)))\nprint(\"정렬된 튜플:\", sorted_tuple)"
      }
    ],
    "categoryId": 3,
    "order": 3,
    "prevSlug": "dictionaries",
    "nextSlug": "sets"
  },
  {
    "id": 10,
    "slug": "sets",
    "title": "Sets",
    "titleKo": "집합",
    "description": "중복되지 않는 요소들의 모음인 집합을 학습합니다.",
    "code": "# 집합 생성\nfruits = {\"사과\", \"바나나\", \"오렌지\"}\nnumbers = set([1, 2, 3, 4, 5])\nprint(\"과일 집합:\", fruits)\nprint(\"숫자 집합:\", numbers)\n\n# 중복 제거\nduplicate_list = [1, 2, 2, 3, 3, 3, 4]\nunique_numbers = set(duplicate_list)\nprint(\"중복 제거:\", unique_numbers)\n\n# 집합 연산\nset1 = {1, 2, 3, 4}\nset2 = {3, 4, 5, 6}\n\nprint(\"합집합:\", set1 | set2)  # 또는 set1.union(set2)\nprint(\"교집합:\", set1 & set2)  # 또는 set1.intersection(set2)\nprint(\"차집합:\", set1 - set2)  # 또는 set1.difference(set2)\nprint(\"대칭차집합:\", set1 ^ set2)  # 또는 set1.symmetric_difference(set2)\n\n# 집합 수정\nfruits.add(\"포도\")\nprint(\"추가 후:\", fruits)\n\nfruits.remove(\"바나나\")  # 없으면 에러\nprint(\"제거 후:\", fruits)\n\nfruits.discard(\"키위\")  # 없어도 에러 없음\nprint(\"discard 후:\", fruits)\n\n# 멤버십 테스트\nprint(\"사과가 있나요?\", \"사과\" in fruits)\nprint(\"키위가 있나요?\", \"키위\" in fruits)",
    "explanation": "집합(set)은 중복되지 않는 요소들의 모음입니다. 수학의 집합 개념과 유사합니다.\n\n주요 특징:\n- 중복 요소 없음\n- 순서 없음 (인덱스 접근 불가)\n- 변경 가능 (mutable)\n- 중괄호 {} 사용\n- 해시 가능한 요소만 저장 가능\n\n집합 연산:\n- 합집합 (union): |\n- 교집합 (intersection): &\n- 차집합 (difference): -\n- 대칭차집합 (symmetric_difference): ^\n\n사용 사례:\n- 중복 제거\n- 멤버십 테스트 (빠른 검색)\n- 수학적 집합 연산",
    "additionalExamples": [
      {
        "title": "집합 비교",
        "code": "# 부분집합과 상위집합\nsmall_set = {1, 2}\nbig_set = {1, 2, 3, 4, 5}\n\nprint(\"부분집합인가?\", small_set.issubset(big_set))\nprint(\"상위집합인가?\", big_set.issuperset(small_set))\nprint(\"서로소인가?\", small_set.isdisjoint({6, 7, 8}))\n\n# frozenset (불변 집합)\nimmutable_set = frozenset([1, 2, 3])\nprint(\"불변 집합:\", immutable_set)"
      }
    ],
    "categoryId": 3,
    "order": 4,
    "prevSlug": "tuples",
    "nextSlug": "functions"
  },
  {
    "id": 11,
    "slug": "functions",
    "title": "Functions",
    "titleKo": "함수",
    "description": "코드를 재사용 가능한 블록으로 만드는 함수를 학습합니다.",
    "code": "# 기본 함수 정의\ndef greet(name):\n    \"\"\"사용자에게 인사하는 함수\"\"\"\n    return f\"안녕하세요, {name}님!\"\n\n# 함수 호출\nmessage = greet(\"김철수\")\nprint(message)\n\n# 여러 매개변수\ndef add_numbers(a, b):\n    \"\"\"두 수를 더하는 함수\"\"\"\n    result = a + b\n    return result\n\nsum_result = add_numbers(5, 3)\nprint(f\"5 + 3 = {sum_result}\")\n\n# 기본값이 있는 매개변수\ndef introduce(name, age=20, city=\"서울\"):\n    return f\"저는 {city}에 사는 {age}살 {name}입니다.\"\n\nprint(introduce(\"이영희\"))\nprint(introduce(\"박민수\", 25))\nprint(introduce(\"최지현\", 22, \"부산\"))\n\n# 여러 값 반환\ndef get_rectangle_info(width, height):\n    area = width * height\n    perimeter = 2 * (width + height)\n    return area, perimeter  # 튜플로 반환\n\nrect_area, rect_perimeter = get_rectangle_info(4, 5)\nprint(f\"면적: {rect_area}, 둘레: {rect_perimeter}\")\n\n# 지역 변수와 전역 변수\nglobal_var = \"전역 변수\"\n\ndef test_scope():\n    local_var = \"지역 변수\"\n    print(f\"함수 내부: {global_var}, {local_var}\")\n\ntest_scope()\nprint(f\"함수 외부: {global_var}\")",
    "explanation": "함수는 특정 작업을 수행하는 코드 블록입니다. 코드의 재사용성과 모듈화를 위해 사용됩니다.\n\n함수 정의:\ndef 함수명(매개변수):\n    \"\"\"문서 문자열\"\"\"\n    실행할 코드\n    return 반환값\n\n주요 개념:\n- 매개변수(parameter): 함수 정의시 사용\n- 인수(argument): 함수 호출시 전달하는 값\n- 기본값: 매개변수에 기본값 설정 가능\n- 반환값: return문으로 값 반환\n- 문서 문자열: 함수 설명\n\n스코프(범위):\n- 지역 변수: 함수 내부에서만 사용\n- 전역 변수: 프로그램 전체에서 사용",
    "additionalExamples": [
      {
        "title": "가변 인수",
        "code": "# 가변 인수 (*args)\ndef sum_all(*numbers):\n    total = 0\n    for num in numbers:\n        total += num\n    return total\n\nprint(\"합계:\", sum_all(1, 2, 3, 4, 5))\n\n# 키워드 인수 (**kwargs)\ndef print_info(**info):\n    for key, value in info.items():\n        print(f\"{key}: {value}\")\n\nprint_info(이름=\"김철수\", 나이=20, 도시=\"서울\")"
      }
    ],
    "categoryId": 4,
    "order": 1,
    "prevSlug": "sets",
    "nextSlug": "lambda"
  },
  {
    "id": 12,
    "slug": "lambda",
    "title": "Lambda Functions",
    "titleKo": "람다 함수",
    "description": "간단한 익명 함수인 람다 함수를 학습합니다.",
    "code": "# 기본 람다 함수\nsquare = lambda x: x ** 2\nprint(\"5의 제곱:\", square(5))\n\n# 일반 함수와 비교\ndef square_func(x):\n    return x ** 2\n\nprint(\"함수로 계산:\", square_func(5))\nprint(\"람다로 계산:\", square(5))\n\n# 여러 매개변수\nadd = lambda x, y: x + y\nprint(\"3 + 7 =\", add(3, 7))\n\n# 조건부 표현식과 함께\nmax_value = lambda a, b: a if a > b else b\nprint(\"최대값:\", max_value(10, 15))\n\n# 리스트와 함께 사용\nnumbers = [1, 2, 3, 4, 5]\n\n# map() 함수와 함께\nsquared = list(map(lambda x: x**2, numbers))\nprint(\"제곱 리스트:\", squared)\n\n# filter() 함수와 함께\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))\nprint(\"짝수 리스트:\", even_numbers)\n\n# sorted() 함수와 함께\nstudents = [('김철수', 85), ('이영희', 92), ('박민수', 78)]\nsorted_by_score = sorted(students, key=lambda student: student[1])\nprint(\"점수순 정렬:\", sorted_by_score)\n\n# 람다 함수 리스트\noperations = [\n    lambda x: x + 1,\n    lambda x: x * 2,\n    lambda x: x ** 2\n]\n\nvalue = 5\nfor i, op in enumerate(operations):\n    result = op(value)\n    print(f\"연산 {i+1}: {value} -> {result}\")",
    "explanation": "람다 함수는 이름이 없는 익명 함수로, 간단한 함수를 한 줄로 정의할 때 사용합니다.\n\n문법:\nlambda 매개변수: 표현식\n\n특징:\n- 한 줄로 간단하게 정의\n- 표현식만 포함 (문장 불가)\n- 자동으로 표현식 결과 반환\n- 주로 고차 함수와 함께 사용\n\n자주 사용되는 고차 함수:\n- map(): 각 요소에 함수 적용\n- filter(): 조건에 맞는 요소 필터링\n- sorted(): 정렬 키 함수로 사용\n\n언제 사용?\n- 간단한 일회성 함수\n- 콜백 함수\n- 함수형 프로그래밍",
    "additionalExamples": [
      {
        "title": "복잡한 람다 활용",
        "code": "# 중첩 람다\nmultiply = lambda x: lambda y: x * y\ndouble = multiply(2)\ntriple = multiply(3)\n\nprint(\"2배:\", double(5))\nprint(\"3배:\", triple(5))\n\n# 딕셔너리 정렬\ndata = [{'name': '김철수', 'age': 25}, {'name': '이영희', 'age': 20}]\nsorted_data = sorted(data, key=lambda x: x['age'])\nprint(\"나이순 정렬:\", sorted_data)"
      }
    ],
    "categoryId": 4,
    "order": 2,
    "prevSlug": "functions",
    "nextSlug": "classes"
  },
  {
    "id": 13,
    "slug": "classes",
    "title": "Classes",
    "titleKo": "클래스",
    "description": "객체지향 프로그래밍의 기본인 클래스를 학습합니다.",
    "code": "# 기본 클래스 정의\nclass Person:\n    # 클래스 변수\n    species = \"호모 사피엔스\"\n    \n    def __init__(self, name, age):\n        \"\"\"생성자 메서드\"\"\"\n        self.name = name  # 인스턴스 변수\n        self.age = age\n    \n    def introduce(self):\n        \"\"\"자기소개 메서드\"\"\"\n        return f\"안녕하세요, 저는 {self.name}이고 {self.age}살입니다.\"\n    \n    def have_birthday(self):\n        \"\"\"생일 메서드\"\"\"\n        self.age += 1\n        return f\"{self.name}님, 생일 축하합니다! 이제 {self.age}살이에요.\"\n\n# 객체 생성\nperson1 = Person(\"김철수\", 25)\nperson2 = Person(\"이영희\", 22)\n\n# 메서드 호출\nprint(person1.introduce())\nprint(person2.introduce())\n\n# 속성 접근\nprint(f\"{person1.name}의 나이: {person1.age}\")\nprint(f\"종: {Person.species}\")\n\n# 메서드 실행\nprint(person1.have_birthday())\nprint(f\"생일 후 나이: {person1.age}\")\n\n# 동적 속성 추가\nperson1.job = \"개발자\"\nprint(f\"{person1.name}의 직업: {person1.job}\")\n\n# 클래스와 인스턴스 확인\nprint(f\"person1은 Person의 인스턴스인가? {isinstance(person1, Person)}\")\nprint(f\"Person은 person1의 클래스인가? {type(person1) == Person}\")",
    "explanation": "클래스는 객체를 만들기 위한 설계도입니다. 데이터(속성)와 기능(메서드)을 하나로 묶어서 관리합니다.\n\n기본 구조:\nclass 클래스명:\n    def __init__(self, 매개변수):  # 생성자\n        self.속성 = 값\n    \n    def 메서드명(self):\n        return 값\n\n주요 개념:\n- __init__: 생성자 메서드 (객체 초기화)\n- self: 인스턴스 자신을 가리키는 매개변수\n- 인스턴스 변수: 각 객체마다 고유한 값\n- 클래스 변수: 모든 인스턴스가 공유하는 값\n- 메서드: 클래스 내부의 함수\n\n객체지향의 장점:\n- 코드 재사용성\n- 유지보수 용이\n- 모듈화",
    "additionalExamples": [
      {
        "title": "특수 메서드",
        "code": "class Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def __str__(self):\n        return f\"직사각형({self.width}x{self.height})\"\n    \n    def __repr__(self):\n        return f\"Rectangle({self.width}, {self.height})\"\n    \n    def area(self):\n        return self.width * self.height\n\nrect = Rectangle(4, 5)\nprint(rect)  # __str__ 호출\nprint(repr(rect))  # __repr__ 호출\nprint(f\"넓이: {rect.area()}\")"
      }
    ],
    "categoryId": 5,
    "order": 1,
    "prevSlug": "lambda",
    "nextSlug": "inheritance"
  },
  {
    "id": 14,
    "slug": "inheritance",
    "title": "Inheritance",
    "titleKo": "상속",
    "description": "기존 클래스를 확장하여 새로운 클래스를 만드는 상속을 학습합니다.",
    "code": "# 부모 클래스\nclass Animal:\n    def __init__(self, name, species):\n        self.name = name\n        self.species = species\n    \n    def make_sound(self):\n        return f\"{self.name}이(가) 소리를 냅니다.\"\n    \n    def introduce(self):\n        return f\"저는 {self.species} {self.name}입니다.\"\n\n# 자식 클래스 1\nclass Dog(Animal):\n    def __init__(self, name, breed):\n        super().__init__(name, \"개\")  # 부모 클래스 초기화\n        self.breed = breed\n    \n    def make_sound(self):  # 메서드 오버라이딩\n        return f\"{self.name}이(가) 멍멍 짖습니다.\"\n    \n    def fetch(self):\n        return f\"{self.name}이(가) 공을 가져옵니다.\"\n\n# 자식 클래스 2\nclass Cat(Animal):\n    def __init__(self, name, color):\n        super().__init__(name, \"고양이\")\n        self.color = color\n    \n    def make_sound(self):\n        return f\"{self.name}이(가) 야옹 웁니다.\"\n    \n    def climb(self):\n        return f\"{self.name}이(가) 나무에 올라갑니다.\"\n\n# 객체 생성 및 사용\ndog = Dog(\"바둑이\", \"골든 리트리버\")\ncat = Cat(\"나비\", \"검은색\")\n\nprint(\"=== 강아지 ===\")\nprint(dog.introduce())\nprint(dog.make_sound())\nprint(dog.fetch())\nprint(f\"견종: {dog.breed}\")\n\nprint(\"\\n=== 고양이 ===\")\nprint(cat.introduce())\nprint(cat.make_sound())\nprint(cat.climb())\nprint(f\"색깔: {cat.color}\")\n\n# 다형성 (Polymorphism)\nanimals = [dog, cat]\nprint(\"\\n=== 다형성 예제 ===\")\nfor animal in animals:\n    print(animal.make_sound())\n\n# 상속 관계 확인\nprint(f\"\\ndog는 Animal의 인스턴스인가? {isinstance(dog, Animal)}\")\nprint(f\"dog는 Dog의 인스턴스인가? {isinstance(dog, Dog)}\")\nprint(f\"Dog는 Animal의 하위 클래스인가? {issubclass(Dog, Animal)}\")",
    "explanation": "상속은 기존 클래스(부모 클래스)의 속성과 메서드를 새로운 클래스(자식 클래스)가 물려받는 것입니다.\n\n상속 문법:\nclass 자식클래스(부모클래스):\n    def __init__(self, ...):\n        super().__init__(...)  # 부모 초기화\n\n주요 개념:\n- super(): 부모 클래스 참조\n- 메서드 오버라이딩: 부모 메서드를 자식에서 재정의\n- 다형성: 같은 메서드 호출로 다른 동작\n- isinstance(): 인스턴스 타입 확인\n- issubclass(): 상속 관계 확인\n\n상속의 장점:\n- 코드 재사용\n- 계층적 구조\n- 유지보수 용이\n- 확장성",
    "additionalExamples": [
      {
        "title": "다중 상속",
        "code": "# 다중 상속 예제\nclass Flyable:\n    def fly(self):\n        return \"하늘을 날아갑니다.\"\n\nclass Swimmable:\n    def swim(self):\n        return \"물에서 헤엄칩니다.\"\n\nclass Duck(Animal, Flyable, Swimmable):\n    def __init__(self, name):\n        Animal.__init__(self, name, \"오리\")\n    \n    def make_sound(self):\n        return f\"{self.name}이(가) 꽥꽥 웁니다.\"\n\nduck = Duck(\"도날드\")\nprint(duck.introduce())\nprint(duck.fly())\nprint(duck.swim())"
      }
    ],
    "categoryId": 5,
    "order": 2,
    "prevSlug": "classes",
    "nextSlug": "modules"
  },
  {
    "id": 15,
    "slug": "modules",
    "title": "Modules",
    "titleKo": "모듈",
    "description": "코드를 파일로 나누어 관리하는 모듈 시스템을 학습합니다.",
    "code": "# 내장 모듈 import\nimport math\nimport random\nimport datetime\nfrom collections import Counter\n\n# math 모듈 사용\nprint(\"수학 계산:\")\nprint(f\"파이 값: {math.pi}\")\nprint(f\"제곱근 16: {math.sqrt(16)}\")\nprint(f\"3의 4제곱: {math.pow(3, 4)}\")\nprint(f\"팩토리얼 5: {math.factorial(5)}\")\n\n# random 모듈 사용\nprint(\"\\n랜덤 숫자:\")\nprint(f\"1-10 사이 정수: {random.randint(1, 10)}\")\nprint(f\"0-1 사이 실수: {random.random()}\")\n\ncolors = [\"빨강\", \"파랑\", \"노랑\", \"초록\"]\nprint(f\"랜덤 색상: {random.choice(colors)}\")\n\nrandom.shuffle(colors)\nprint(f\"섞인 색상: {colors}\")\n\n# datetime 모듈 사용\nprint(\"\\n날짜와 시간:\")\nnow = datetime.datetime.now()\nprint(f\"현재 시간: {now}\")\nprint(f\"년도: {now.year}\")\nprint(f\"월: {now.month}\")\nprint(f\"일: {now.day}\")\n\nbirthday = datetime.date(2000, 5, 15)\nprint(f\"생일: {birthday}\")\nage_days = (datetime.date.today() - birthday).days\nprint(f\"태어난 지 {age_days}일\")\n\n# collections 모듈 사용\nprint(\"\\n컬렉션:\")\nwords = [\"사과\", \"바나나\", \"사과\", \"오렌지\", \"바나나\", \"사과\"]\nword_count = Counter(words)\nprint(f\"단어 개수: {word_count}\")\nprint(f\"가장 많은 단어: {word_count.most_common(1)}\")\n\n# 별칭 사용\nimport datetime as dt\ntoday = dt.date.today()\nprint(f\"\\n오늘 날짜 (별칭 사용): {today}\")",
    "explanation": "모듈은 파이썬 코드가 들어있는 파일입니다. 코드를 논리적으로 구성하고 재사용할 수 있게 해줍니다.\n\nimport 방법:\n- import 모듈명\n- from 모듈명 import 함수명\n- import 모듈명 as 별칭\n- from 모듈명 import *\n\n내장 모듈 예시:\n- math: 수학 함수\n- random: 난수 생성\n- datetime: 날짜/시간 처리\n- os: 운영체제 인터페이스\n- sys: 시스템 관련\n- json: JSON 데이터 처리\n- re: 정규표현식\n\n모듈 사용의 장점:\n- 코드 구조화\n- 재사용성\n- 네임스페이스 분리\n- 협업 용이",
    "additionalExamples": [
      {
        "title": "사용자 정의 모듈",
        "code": "# 가상의 calculator.py 모듈\n# def add(a, b):\n#     return a + b\n# \n# def subtract(a, b):\n#     return a - b\n# \n# PI = 3.14159\n\n# 사용 예시 (실제로는 파일이 있어야 함)\n# import calculator\n# print(calculator.add(5, 3))\n# print(calculator.PI)\n\n# 모듈 정보 확인\nimport math\nprint(f\"math 모듈 위치: {math.__file__}\")\nprint(f\"math 모듈 함수들: {dir(math)[:5]}...\")  # 처음 5개만"
      }
    ],
    "categoryId": 6,
    "order": 1,
    "prevSlug": "inheritance",
    "nextSlug": "packages"
  },
  {
    "id": 16,
    "slug": "packages",
    "title": "Packages",
    "titleKo": "패키지",
    "description": "모듈들을 디렉토리로 구조화하는 패키지 시스템을 학습합니다.",
    "code": "# 패키지 import 예제\n# 실제 파일 구조:\n# mypackage/\n#     __init__.py\n#     module1.py\n#     module2.py\n#     subpackage/\n#         __init__.py\n#         submodule.py\n\n# 표준 라이브러리 패키지 사용\nfrom urllib.parse import urlparse\nfrom urllib.request import urlopen\nimport json\n\n# URL 파싱 예제\nurl = \"https://www.example.com/path?param=value\"\nparsed = urlparse(url)\nprint(\"URL 파싱:\")\nprint(f\"스키마: {parsed.scheme}\")\nprint(f\"호스트: {parsed.netloc}\")\nprint(f\"경로: {parsed.path}\")\nprint(f\"쿼리: {parsed.query}\")\n\n# JSON 패키지 사용\ndata = {\n    \"이름\": \"김철수\",\n    \"나이\": 25,\n    \"취미\": [\"독서\", \"영화감상\", \"프로그래밍\"]\n}\n\n# JSON 문자열로 변환\njson_string = json.dumps(data, ensure_ascii=False, indent=2)\nprint(\"\\nJSON 변환:\")\nprint(json_string)\n\n# JSON 문자열을 다시 딕셔너리로\nparsed_data = json.loads(json_string)\nprint(\"\\nJSON 파싱:\")\nprint(f\"이름: {parsed_data['이름']}\")\nprint(f\"취미: {', '.join(parsed_data['취미'])}\")\n\n# os 패키지 사용\nimport os\nfrom pathlib import Path\n\nprint(\"\\n시스템 정보:\")\nprint(f\"현재 작업 디렉토리: {os.getcwd()}\")\nprint(f\"운영체제: {os.name}\")\nprint(f\"환경 변수 PATH 존재: {'PATH' in os.environ}\")\n\n# pathlib 사용 (모던한 경로 처리)\ncurrent_path = Path(\".\")\nprint(f\"\\n현재 경로: {current_path.absolute()}\")\nprint(f\"부모 디렉토리: {current_path.parent.absolute()}\")\n\n# 가상의 패키지 구조 설명\nprint(\"\\n=== 패키지 구조 예제 ===\")\npackage_structure = \"\"\"\nmyproject/\n    __init__.py          # 패키지 초기화\n    utils/\n        __init__.py\n        helpers.py       # 도우미 함수들\n        constants.py     # 상수들\n    models/\n        __init__.py\n        user.py          # 사용자 모델\n        product.py       # 제품 모델\n    main.py              # 메인 실행 파일\n\"\"\"\nprint(package_structure)",
    "explanation": "패키지는 관련된 모듈들을 디렉토리로 구조화한 것입니다. 대규모 프로젝트에서 코드를 체계적으로 관리할 수 있습니다.\n\n패키지 구조:\n- __init__.py: 패키지임을 나타내는 파일\n- 하위 디렉토리에도 __init__.py 필요\n- 모듈들을 논리적으로 그룹화\n\n패키지 import:\n- import package.module\n- from package import module\n- from package.module import function\n\n표준 라이브러리 패키지:\n- urllib: URL 처리\n- json: JSON 데이터 처리\n- os: 운영체제 인터페이스\n- pathlib: 경로 처리 (Python 3.4+)\n- collections: 특수 컨테이너\n- itertools: 반복자 도구\n\n패키지의 장점:\n- 코드 구조화\n- 네임스페이스 관리\n- 모듈 간 의존성 관리",
    "additionalExamples": [
      {
        "title": "__init__.py 활용",
        "code": "# __init__.py 파일의 역할\n# 1. 패키지 초기화 코드\n# 2. __all__ 변수로 public API 정의\n# 3. 하위 모듈 import 단순화\n\n# 예시 __init__.py 내용:\n# from .module1 import function1\n# from .module2 import Class2\n# \n# __all__ = ['function1', 'Class2']\n# \n# # 패키지 버전 정보\n# __version__ = '1.0.0'\n\n# 상대 import 예시\n# from . import sibling_module\n# from .. import parent_module\n# from ..other_package import some_module\n\nprint(\"패키지 시스템을 통한 코드 구조화의 중요성:\")\nprint(\"1. 관련 기능별로 모듈 그룹화\")\nprint(\"2. 네임스페이스 충돌 방지\")\nprint(\"3. 코드 재사용성 향상\")\nprint(\"4. 대규모 프로젝트 관리 용이\")"
      }
    ],
    "categoryId": 6,
    "order": 2,
    "prevSlug": "modules",
    "nextSlug": "file-io"
  },
  {
    "id": 17,
    "slug": "file-io",
    "title": "File I/O",
    "titleKo": "파일 입출력",
    "description": "파일을 읽고 쓰는 방법을 학습합니다.",
    "code": "# 파일 쓰기\nprint(\"=== 파일 쓰기 ===\")\n\n# 텍스트 파일 쓰기\nwith open('example.txt', 'w', encoding='utf-8') as file:\n    file.write('안녕하세요!\\n')\n    file.write('파이썬 파일 입출력 예제입니다.\\n')\n    \n    # 여러 줄 쓰기\n    lines = ['첫 번째 줄\\n', '두 번째 줄\\n', '세 번째 줄\\n']\n    file.writelines(lines)\n\nprint(\"파일 쓰기 완료\")\n\n# 파일 읽기\nprint(\"\\n=== 파일 읽기 ===\")\n\n# 전체 내용 읽기\nwith open('example.txt', 'r', encoding='utf-8') as file:\n    content = file.read()\n    print(\"전체 내용:\")\n    print(content)\n\n# 한 줄씩 읽기\nprint(\"한 줄씩 읽기:\")\nwith open('example.txt', 'r', encoding='utf-8') as file:\n    line_number = 1\n    for line in file:\n        print(f\"{line_number}: {line.strip()}\")\n        line_number += 1\n\n# readlines() 사용\nwith open('example.txt', 'r', encoding='utf-8') as file:\n    lines = file.readlines()\n    print(f\"\\n총 {len(lines)}줄 읽음\")\n\n# 파일 추가 (append)\nprint(\"\\n=== 파일 추가 ===\")\nwith open('example.txt', 'a', encoding='utf-8') as file:\n    file.write('추가된 줄\\n')\n    file.write('마지막 줄\\n')\n\nprint(\"파일 추가 완료\")\n\n# 파일 정보 확인\nimport os\nfrom pathlib import Path\n\nprint(\"\\n=== 파일 정보 ===\")\nfile_path = Path('example.txt')\nif file_path.exists():\n    file_size = file_path.stat().st_size\n    print(f\"파일 크기: {file_size} 바이트\")\n    print(f\"파일 존재: {file_path.exists()}\")\n    print(f\"절대 경로: {file_path.absolute()}\")\n\n# 예외 처리\nprint(\"\\n=== 예외 처리 ===\")\ntry:\n    with open('nonexistent.txt', 'r') as file:\n        content = file.read()\nexcept FileNotFoundError:\n    print(\"파일을 찾을 수 없습니다.\")\nexcept PermissionError:\n    print(\"파일 접근 권한이 없습니다.\")\nexcept Exception as e:\n    print(f\"예상치 못한 오류: {e}\")",
    "explanation": "파일 입출력은 데이터를 파일에 저장하거나 파일에서 읽어오는 작업입니다.\n\n파일 모드:\n- 'r': 읽기 모드 (기본값)\n- 'w': 쓰기 모드 (덮어쓰기)\n- 'a': 추가 모드\n- 'x': 배타적 생성\n- 'b': 바이너리 모드 (예: 'rb', 'wb')\n- 't': 텍스트 모드 (기본값)\n\nwith 문 사용:\n- 자동으로 파일 닫기\n- 예외 발생시에도 안전하게 파일 닫기\n- 권장되는 방법\n\n주요 메서드:\n- read(): 전체 내용 읽기\n- readline(): 한 줄 읽기\n- readlines(): 모든 줄을 리스트로\n- write(): 문자열 쓰기\n- writelines(): 문자열 리스트 쓰기\n\nencoding 지정이 중요 (한글 처리)",
    "additionalExamples": [
      {
        "title": "CSV 파일 처리",
        "code": "import csv\nfrom io import StringIO\n\n# CSV 데이터 (실제로는 파일에서 읽음)\ncsv_data = \"\"\"이름,나이,도시\n김철수,25,서울\n이영희,30,부산\n박민수,28,대구\"\"\"\n\n# CSV 읽기\nprint(\"CSV 데이터 읽기:\")\ncsv_file = StringIO(csv_data)\nreader = csv.DictReader(csv_file)\nfor row in reader:\n    print(f\"이름: {row['이름']}, 나이: {row['나이']}, 도시: {row['도시']}\")\n\n# JSON 파일 처리\nimport json\n\ndata = {\"users\": [{\"name\": \"김철수\", \"age\": 25}]}\nprint(f\"\\nJSON 형태: {json.dumps(data, ensure_ascii=False)}\")"
      }
    ],
    "categoryId": 7,
    "order": 1,
    "prevSlug": "packages",
    "nextSlug": "exception-handling"
  },
  {
    "id": 18,
    "slug": "exception-handling",
    "title": "Exception Handling",
    "titleKo": "예외 처리",
    "description": "프로그램 실행 중 발생하는 오류를 처리하는 방법을 학습합니다.",
    "code": "# 기본 예외 처리\nprint(\"=== 기본 try-except ===\")\n\ntry:\n    number = int(input(\"숫자를 입력하세요 (테스트용으로 'abc' 입력): \"))\n    result = 10 / number\n    print(f\"결과: {result}\")\nexcept ValueError:\n    print(\"올바른 숫자를 입력해주세요.\")\nexcept ZeroDivisionError:\n    print(\"0으로 나눌 수 없습니다.\")\n\n# 시뮬레이션을 위한 함수들\ndef simulate_input_error():\n    # ValueError 시뮬레이션\n    try:\n        value = int(\"abc\")  # 의도적으로 오류 발생\n    except ValueError as e:\n        print(f\"ValueError 발생: {e}\")\n\ndef simulate_zero_division():\n    # ZeroDivisionError 시뮬레이션\n    try:\n        result = 10 / 0\n    except ZeroDivisionError as e:\n        print(f\"ZeroDivisionError 발생: {e}\")\n\nsimulate_input_error()\nsimulate_zero_division()\n\n# 여러 예외 한번에 처리\nprint(\"\\n=== 여러 예외 처리 ===\")\n\ndef divide_numbers(a, b):\n    try:\n        # 문자열을 숫자로 변환\n        num1 = float(a)\n        num2 = float(b)\n        result = num1 / num2\n        return result\n    except (ValueError, TypeError) as e:\n        print(f\"입력 오류: {e}\")\n        return None\n    except ZeroDivisionError:\n        print(\"0으로 나눌 수 없습니다.\")\n        return None\n    except Exception as e:\n        print(f\"예상치 못한 오류: {e}\")\n        return None\n\n# 테스트\nprint(divide_numbers(\"10\", \"2\"))    # 정상\nprint(divide_numbers(\"10\", \"abc\"))  # ValueError\nprint(divide_numbers(\"10\", \"0\"))    # ZeroDivisionError\n\n# finally 절\nprint(\"\\n=== finally 절 ===\")\n\ndef read_file_simulation(filename):\n    file = None\n    try:\n        if filename == \"nonexistent.txt\":\n            raise FileNotFoundError(\"파일을 찾을 수 없습니다.\")\n        \n        print(f\"{filename} 파일을 읽는 중...\")\n        # 파일 읽기 시뮬레이션\n        file = \"file_object\"  # 실제로는 파일 객체\n        return \"파일 내용\"\n    \n    except FileNotFoundError as e:\n        print(f\"파일 오류: {e}\")\n        return None\n    \n    finally:\n        if file:\n            print(\"파일을 닫습니다.\")\n        print(\"정리 작업 완료\")\n\nread_file_simulation(\"example.txt\")\nread_file_simulation(\"nonexistent.txt\")\n\n# 사용자 정의 예외\nprint(\"\\n=== 사용자 정의 예외 ===\")\n\nclass CustomError(Exception):\n    \"\"\"사용자 정의 예외 클래스\"\"\"\n    def __init__(self, message):\n        self.message = message\n        super().__init__(self.message)\n\nclass AgeError(CustomError):\n    \"\"\"나이 관련 예외\"\"\"\n    pass\n\ndef check_age(age):\n    if age < 0:\n        raise AgeError(\"나이는 0보다 작을 수 없습니다.\")\n    elif age > 150:\n        raise AgeError(\"나이는 150보다 클 수 없습니다.\")\n    else:\n        print(f\"유효한 나이: {age}세\")\n\n# 사용자 정의 예외 테스트\ntry:\n    check_age(25)   # 정상\n    check_age(-5)   # AgeError\nexcept AgeError as e:\n    print(f\"나이 오류: {e}\")\n\ntry:\n    check_age(200)  # AgeError\nexcept AgeError as e:\n    print(f\"나이 오류: {e}\")",
    "explanation": "예외 처리는 프로그램 실행 중 발생할 수 있는 오류를 우아하게 처리하는 방법입니다.\n\n기본 구조:\ntry:\n    오류가 발생할 수 있는 코드\nexcept 예외타입:\n    오류 처리 코드\nelse:\n    오류가 없을 때 실행\nfinally:\n    항상 실행되는 코드\n\n일반적인 예외:\n- ValueError: 잘못된 값\n- TypeError: 잘못된 타입\n- ZeroDivisionError: 0으로 나누기\n- FileNotFoundError: 파일 없음\n- IndexError: 인덱스 범위 초과\n- KeyError: 딕셔너리 키 없음\n\n예외 처리의 장점:\n- 프로그램 안정성\n- 사용자 친화적 오류 메시지\n- 디버깅 정보 제공",
    "additionalExamples": [
      {
        "title": "assert와 로깅",
        "code": "# assert 문 사용\ndef calculate_average(numbers):\n    assert len(numbers) > 0, \"빈 리스트는 평균을 계산할 수 없습니다.\"\n    assert all(isinstance(n, (int, float)) for n in numbers), \"모든 요소가 숫자여야 합니다.\"\n    return sum(numbers) / len(numbers)\n\ntry:\n    print(calculate_average([1, 2, 3, 4, 5]))\n    # calculate_average([])  # AssertionError\nexcept AssertionError as e:\n    print(f\"Assertion 오류: {e}\")\n\n# 로깅 (간단한 예시)\nimport logging\nlogging.basicConfig(level=logging.INFO)\n\ntry:\n    result = 10 / 2\n    logging.info(f\"계산 성공: {result}\")\nexcept Exception as e:\n    logging.error(f\"계산 실패: {e}\")"
      }
    ],
    "categoryId": 7,
    "order": 2,
    "prevSlug": "file-io",
    "nextSlug": "generators"
  },
  {
    "id": 19,
    "slug": "generators",
    "title": "Generators",
    "titleKo": "제너레이터",
    "description": "메모리 효율적인 이터레이터인 제너레이터를 학습합니다.",
    "code": "# 기본 제너레이터 함수\nprint(\"=== 기본 제너레이터 ===\")\n\ndef simple_generator():\n    \"\"\"간단한 제너레이터 함수\"\"\"\n    print(\"제너레이터 시작\")\n    yield 1\n    print(\"첫 번째 yield 후\")\n    yield 2\n    print(\"두 번째 yield 후\")\n    yield 3\n    print(\"제너레이터 종료\")\n\n# 제너레이터 사용\ngen = simple_generator()\nprint(f\"제너레이터 객체: {gen}\")\n\nfor value in gen:\n    print(f\"받은 값: {value}\")\n\n# 제너레이터 vs 일반 함수\nprint(\"\\n=== 제너레이터 vs 리스트 ===\")\n\n# 일반 함수 (리스트 반환)\ndef create_list(n):\n    result = []\n    for i in range(n):\n        result.append(i ** 2)\n    return result\n\n# 제너레이터 함수\ndef create_generator(n):\n    for i in range(n):\n        yield i ** 2\n\n# 메모리 사용량 비교 (개념적)\nlist_result = create_list(5)\ngen_result = create_generator(5)\n\nprint(f\"리스트: {list_result}\")\nprint(f\"제너레이터: {gen_result}\")\nprint(f\"제너레이터 내용: {list(create_generator(5))}\")\n\n# 실용적인 제너레이터 예제\nprint(\"\\n=== 실용적인 제너레이터 ===\")\n\ndef fibonacci_generator(n):\n    \"\"\"피보나치 수열 제너레이터\"\"\"\n    a, b = 0, 1\n    count = 0\n    while count < n:\n        yield a\n        a, b = b, a + b\n        count += 1\n\nprint(\"피보나치 수열 (처음 10개):\")\nfor num in fibonacci_generator(10):\n    print(num, end=\" \")\nprint()\n\n# 파일 읽기 제너레이터 (시뮬레이션)\ndef read_large_file_simulation():\n    \"\"\"큰 파일을 한 줄씩 읽는 제너레이터\"\"\"\n    lines = [\n        \"첫 번째 줄\",\n        \"두 번째 줄\",\n        \"세 번째 줄\",\n        \"네 번째 줄\",\n        \"다섯 번째 줄\"\n    ]\n    for line in lines:\n        yield line.strip()\n\nprint(\"\\n파일 내용 (한 줄씩):\")\nfor line in read_large_file_simulation():\n    print(f\"처리중: {line}\")\n\n# 제너레이터 표현식\nprint(\"\\n=== 제너레이터 표현식 ===\")\n\n# 리스트 컴프리헨션 vs 제너레이터 표현식\nlist_comp = [x**2 for x in range(5)]  # 리스트 컴프리헨션\ngen_exp = (x**2 for x in range(5))    # 제너레이터 표현식\n\nprint(f\"리스트 컴프리헨션: {list_comp}\")\nprint(f\"제너레이터 표현식: {gen_exp}\")\nprint(f\"제너레이터 표현식 내용: {list(gen_exp)}\")\n\n# 큰 데이터 처리 예제\ndef process_large_dataset(data_size):\n    \"\"\"큰 데이터셋을 처리하는 제너레이터\"\"\"\n    for i in range(data_size):\n        # 복잡한 처리 시뮬레이션\n        processed_value = (i * 2) ** 0.5\n        yield processed_value\n\nprint(\"\\n큰 데이터 처리 (처음 5개만):\")\ndata_gen = process_large_dataset(1000000)  # 100만 개 데이터\nfor i, value in enumerate(data_gen):\n    if i >= 5:  # 처음 5개만 출력\n        break\n    print(f\"데이터 {i}: {value:.2f}\")\n\n# send()와 close() 메서드\nprint(\"\\n=== 고급 제너레이터 제어 ===\")\n\ndef advanced_generator():\n    \"\"\"값을 받을 수 있는 제너레이터\"\"\"\n    total = 0\n    while True:\n        value = yield total\n        if value is not None:\n            total += value\n\ngen = advanced_generator()\nnext(gen)  # 제너레이터 시작\nprint(f\"초기값: {gen.send(10)}\")\nprint(f\"10 추가 후: {gen.send(20)}\")\nprint(f\"20 추가 후: {gen.send(30)}\")\ngen.close()  # 제너레이터 종료",
    "explanation": "제너레이터는 이터레이터를 생성하는 함수로, yield 키워드를 사용합니다. 메모리 효율적이고 지연 평가를 제공합니다.\n\n제너레이터의 특징:\n- yield 키워드 사용\n- 한 번에 하나의 값만 생성\n- 메모리 효율적 (큰 데이터 처리시 유용)\n- 상태 유지 (함수 실행이 일시 중단됨)\n- 이터러블 프로토콜 지원\n\nyield vs return:\n- return: 함수 종료하고 값 반환\n- yield: 값 반환 후 함수 일시 중단\n\n제너레이터 메서드:\n- next(): 다음 값 가져오기\n- send(): 값 전송\n- close(): 제너레이터 종료\n- throw(): 예외 발생\n\n사용 사례:\n- 큰 파일 처리\n- 무한 시퀀스\n- 파이프라인 처리\n- 메모리 절약이 중요한 경우",
    "additionalExamples": [
      {
        "title": "제너레이터 파이프라인",
        "code": "# 제너레이터 체이닝\ndef numbers(start, end):\n    for i in range(start, end):\n        yield i\n\ndef squares(nums):\n    for num in nums:\n        yield num ** 2\n\ndef evens(nums):\n    for num in nums:\n        if num % 2 == 0:\n            yield num\n\n# 파이프라인 구성\nnum_gen = numbers(1, 11)\nsquare_gen = squares(num_gen)\neven_gen = evens(square_gen)\n\nprint(\"짝수 제곱수:\")\nfor value in even_gen:\n    print(value, end=\" \")\nprint()\n\n# 한 줄로 표현\nresult = evens(squares(numbers(1, 11)))\nprint(f\"\\n파이프라인 결과: {list(result)}\")"
      }
    ],
    "categoryId": 8,
    "order": 1,
    "prevSlug": "exception-handling",
    "nextSlug": "decorators"
  },
  {
    "id": 20,
    "slug": "decorators",
    "title": "Decorators",
    "titleKo": "데코레이터",
    "description": "함수나 클래스의 기능을 확장하는 데코레이터를 학습합니다.",
    "code": "# 기본 데코레이터\nprint(\"=== 기본 데코레이터 ===\")\n\nimport time\nfrom functools import wraps\n\ndef timer(func):\n    \"\"\"함수 실행 시간을 측정하는 데코레이터\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"{func.__name__} 실행 시간: {end_time - start_time:.4f}초\")\n        return result\n    return wrapper\n\n@timer\ndef slow_function():\n    \"\"\"느린 함수 시뮬레이션\"\"\"\n    time.sleep(0.1)  # 0.1초 대기\n    return \"작업 완료\"\n\nresult = slow_function()\nprint(f\"결과: {result}\")\n\n# 매개변수가 있는 데코레이터\nprint(\"\\n=== 매개변수가 있는 데코레이터 ===\")\n\ndef repeat(times):\n    \"\"\"함수를 여러 번 실행하는 데코레이터\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            results = []\n            for i in range(times):\n                print(f\"실행 {i+1}:\")\n                result = func(*args, **kwargs)\n                results.append(result)\n            return results\n        return wrapper\n    return decorator\n\n@repeat(3)\ndef greet(name):\n    message = f\"안녕하세요, {name}님!\"\n    print(message)\n    return message\n\nresults = greet(\"김철수\")\nprint(f\"\\n모든 결과: {results}\")\n\n# 여러 데코레이터 적용\nprint(\"\\n=== 여러 데코레이터 ===\")\n\ndef logger(func):\n    \"\"\"함수 호출을 로깅하는 데코레이터\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print(f\"호출: {func.__name__}({args}, {kwargs})\")\n        result = func(*args, **kwargs)\n        print(f\"반환: {result}\")\n        return result\n    return wrapper\n\n@timer\n@logger\ndef calculate(x, y):\n    \"\"\"두 수를 더하는 함수\"\"\"\n    time.sleep(0.05)  # 작업 시뮬레이션\n    return x + y\n\nresult = calculate(5, 3)\n\n# 클래스 기반 데코레이터\nprint(\"\\n=== 클래스 기반 데코레이터 ===\")\n\nclass CallCounter:\n    \"\"\"함수 호출 횟수를 세는 데코레이터 클래스\"\"\"\n    def __init__(self, func):\n        self.func = func\n        self.count = 0\n        # functools.wraps 대신 수동으로 속성 복사\n        self.__name__ = func.__name__\n        self.__doc__ = func.__doc__\n    \n    def __call__(self, *args, **kwargs):\n        self.count += 1\n        print(f\"{self.func.__name__} 호출 횟수: {self.count}\")\n        return self.func(*args, **kwargs)\n\n@CallCounter\ndef say_hello(name):\n    return f\"안녕, {name}!\"\n\nprint(say_hello(\"김철수\"))\nprint(say_hello(\"이영희\"))\nprint(say_hello(\"박민수\"))\nprint(f\"총 호출 횟수: {say_hello.count}\")\n\n# 실용적인 데코레이터 예제\nprint(\"\\n=== 실용적인 데코레이터 ===\")\n\ndef cache(func):\n    \"\"\"간단한 캐시 데코레이터\"\"\"\n    cached_results = {}\n    \n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        # 키 생성 (간단한 방법)\n        key = str(args) + str(sorted(kwargs.items()))\n        \n        if key in cached_results:\n            print(f\"캐시에서 반환: {key}\")\n            return cached_results[key]\n        \n        print(f\"계산 중: {key}\")\n        result = func(*args, **kwargs)\n        cached_results[key] = result\n        return result\n    \n    return wrapper\n\n@cache\ndef expensive_calculation(n):\n    \"\"\"비싼 계산 시뮬레이션\"\"\"\n    time.sleep(0.1)  # 계산 시간 시뮬레이션\n    return n ** 2\n\n# 캐시 테스트\nprint(expensive_calculation(5))  # 계산\nprint(expensive_calculation(5))  # 캐시에서 반환\nprint(expensive_calculation(3))  # 계산\nprint(expensive_calculation(3))  # 캐시에서 반환\n\n# 검증 데코레이터\ndef validate_positive(func):\n    \"\"\"양수만 허용하는 데코레이터\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        for arg in args:\n            if isinstance(arg, (int, float)) and arg <= 0:\n                raise ValueError(f\"양수만 허용됩니다: {arg}\")\n        return func(*args, **kwargs)\n    return wrapper\n\n@validate_positive\ndef square_root(n):\n    return n ** 0.5\n\nprint(f\"\\n√9 = {square_root(9)}\")\ntry:\n    print(square_root(-4))  # 오류 발생\nexcept ValueError as e:\n    print(f\"검증 오류: {e}\")",
    "explanation": "데코레이터는 함수나 클래스의 기능을 수정하거나 확장하는 방법입니다. 코드의 재사용성과 가독성을 높입니다.\n\n데코레이터 문법:\n@decorator_name\ndef function():\n    pass\n\n# 위는 아래와 같음\nfunction = decorator_name(function)\n\n데코레이터 작동 원리:\n1. 원본 함수를 인수로 받음\n2. 래퍼 함수 생성\n3. 래퍼 함수에서 원본 함수 호출\n4. 추가 기능 수행\n5. 래퍼 함수 반환\n\n@functools.wraps 사용 이유:\n- 원본 함수의 메타데이터 보존\n- __name__, __doc__ 등 속성 유지\n\n활용 사례:\n- 로깅, 타이밍, 캐싱\n- 인증, 권한 검사\n- 입력 검증\n- 재시도 로직",
    "additionalExamples": [
      {
        "title": "고급 데코레이터 패턴",
        "code": "# 조건부 데코레이터\ndef conditional_decorator(condition):\n    def decorator(func):\n        if condition:\n            @wraps(func)\n            def wrapper(*args, **kwargs):\n                print(f\"조건부 실행: {func.__name__}\")\n                return func(*args, **kwargs)\n            return wrapper\n        else:\n            return func  # 데코레이터 적용 안 함\n    return decorator\n\n# 사용 예\nDEBUG = True\n\n@conditional_decorator(DEBUG)\ndef debug_function():\n    return \"디버그 함수\"\n\nprint(debug_function())\n\n# 메서드 데코레이터\nclass MyClass:\n    @staticmethod\n    def static_method():\n        return \"정적 메서드\"\n    \n    @classmethod\n    def class_method(cls):\n        return f\"클래스 메서드: {cls.__name__}\"\n    \n    @property\n    def prop(self):\n        return \"프로퍼티\"\n\nobj = MyClass()\nprint(f\"정적: {MyClass.static_method()}\")\nprint(f\"클래스: {MyClass.class_method()}\")\nprint(f\"프로퍼티: {obj.prop}\")"
      }
    ],
    "categoryId": 8,
    "order": 2,
    "prevSlug": "generators",
    "nextSlug": "context-managers"
  },
  {
    "id": 21,
    "slug": "context-managers",
    "title": "Context Managers",
    "titleKo": "컨텍스트 매니저",
    "description": "with 문과 함께 사용하는 컨텍스트 매니저를 학습합니다.",
    "code": "# with 문 기본 사용\nprint(\"=== with 문 기본 사용 ===\")\n\n# 파일 처리 (가장 일반적인 예)\nprint(\"파일 처리 예제:\")\ntry:\n    with open('example.txt', 'w', encoding='utf-8') as f:\n        f.write('컨텍스트 매니저 예제\\n')\n        f.write('자동으로 파일이 닫힙니다\\n')\n    print(\"파일 쓰기 완료\")\nexcept Exception as e:\n    print(f\"파일 처리 오류: {e}\")\n\n# 사용자 정의 컨텍스트 매니저 (클래스 방식)\nprint(\"\\n=== 클래스 기반 컨텍스트 매니저 ===\")\n\nclass Timer:\n    \"\"\"실행 시간을 측정하는 컨텍스트 매니저\"\"\"\n    \n    def __init__(self, name=\"작업\"):\n        self.name = name\n        self.start_time = None\n    \n    def __enter__(self):\n        print(f\"{self.name} 시작\")\n        import time\n        self.start_time = time.time()\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        import time\n        end_time = time.time()\n        elapsed = end_time - self.start_time\n        print(f\"{self.name} 완료: {elapsed:.4f}초\")\n        \n        # 예외 처리\n        if exc_type is not None:\n            print(f\"예외 발생: {exc_type.__name__}: {exc_val}\")\n            return False  # 예외를 다시 발생시킴\n        return True\n\n# Timer 컨텍스트 매니저 사용\nwith Timer(\"계산 작업\"):\n    import time\n    time.sleep(0.1)\n    result = sum(range(1000000))\n    print(f\"계산 결과: {result}\")\n\n# contextlib 모듈 사용\nprint(\"\\n=== contextlib 사용 ===\")\n\nfrom contextlib import contextmanager\nimport time\n\n@contextmanager\ndef timer_context(name=\"작업\"):\n    \"\"\"제너레이터 기반 컨텍스트 매니저\"\"\"\n    print(f\"{name} 시작\")\n    start_time = time.time()\n    \n    try:\n        yield start_time  # with 문의 as 변수에 전달\n    except Exception as e:\n        print(f\"예외 발생: {e}\")\n        raise  # 예외를 다시 발생\n    finally:\n        end_time = time.time()\n        elapsed = end_time - start_time\n        print(f\"{name} 완료: {elapsed:.4f}초\")\n\n# 제너레이터 기반 컨텍스트 매니저 사용\nwith timer_context(\"데이터 처리\") as start:\n    time.sleep(0.05)\n    data = [i**2 for i in range(10000)]\n    print(f\"데이터 생성 완료, 시작 시간: {start:.2f}\")\n\n# 디렉토리 변경 컨텍스트 매니저\nprint(\"\\n=== 디렉토리 변경 컨텍스트 매니저 ===\")\n\nimport os\nfrom contextlib import contextmanager\n\n@contextmanager\ndef change_directory(path):\n    \"\"\"임시로 디렉토리를 변경하는 컨텍스트 매니저\"\"\"\n    original_path = os.getcwd()\n    print(f\"현재 디렉토리: {original_path}\")\n    \n    try:\n        if os.path.exists(path):\n            os.chdir(path)\n            print(f\"디렉토리 변경: {os.getcwd()}\")\n        else:\n            print(f\"경로가 존재하지 않습니다: {path}\")\n        yield os.getcwd()\n    except Exception as e:\n        print(f\"디렉토리 변경 오류: {e}\")\n    finally:\n        os.chdir(original_path)\n        print(f\"디렉토리 복원: {os.getcwd()}\")\n\n# 현재 디렉토리에서 테스트 (존재하는 경로)\nwith change_directory(\".\") as current_dir:\n    print(f\"작업 디렉토리: {current_dir}\")\n    # 여기서 파일 작업 등을 수행\n\n# 데이터베이스 연결 시뮬레이션\nprint(\"\\n=== 데이터베이스 연결 시뮬레이션 ===\")\n\nclass DatabaseConnection:\n    \"\"\"데이터베이스 연결 시뮬레이션\"\"\"\n    \n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.connected = False\n    \n    def connect(self):\n        print(f\"{self.host}:{self.port}에 연결 중...\")\n        self.connected = True\n        print(\"데이터베이스 연결 성공\")\n    \n    def disconnect(self):\n        if self.connected:\n            print(\"데이터베이스 연결 해제\")\n            self.connected = False\n    \n    def execute(self, query):\n        if self.connected:\n            print(f\"쿼리 실행: {query}\")\n            return f\"쿼리 결과: {query} 완료\"\n        else:\n            raise Exception(\"데이터베이스에 연결되지 않음\")\n\n@contextmanager\ndef database_connection(host, port):\n    \"\"\"데이터베이스 연결 컨텍스트 매니저\"\"\"\n    db = DatabaseConnection(host, port)\n    try:\n        db.connect()\n        yield db\n    except Exception as e:\n        print(f\"데이터베이스 오류: {e}\")\n        raise\n    finally:\n        db.disconnect()\n\n# 데이터베이스 컨텍스트 매니저 사용\nwith database_connection(\"localhost\", 5432) as db:\n    result1 = db.execute(\"SELECT * FROM users\")\n    print(result1)\n    result2 = db.execute(\"SELECT * FROM products\")\n    print(result2)\n\n# 예외 처리 테스트\nprint(\"\\n=== 예외 처리 테스트 ===\")\n\ntry:\n    with Timer(\"오류 발생 작업\"):\n        time.sleep(0.05)\n        raise ValueError(\"의도적인 오류\")\nexcept ValueError as e:\n    print(f\"예외 처리됨: {e}\")",
    "explanation": "컨텍스트 매니저는 with 문과 함께 사용되어 리소스를 안전하게 관리하는 객체입니다.\n\n구현 방법:\n1. 클래스 방식: __enter__와 __exit__ 메서드 정의\n2. 제너레이터 방식: @contextmanager 데코레이터 사용\n\n클래스 방식:\nclass MyContext:\n    def __enter__(self):\n        # 초기화 코드\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        # 정리 코드\n        return False  # 예외를 다시 발생\n\n제너레이터 방식:\n@contextmanager\ndef my_context():\n    # 초기화 코드\n    try:\n        yield value\n    finally:\n        # 정리 코드\n\n장점:\n- 자동 리소스 관리\n- 예외 안전성\n- 코드 가독성\n- try-finally 블록 대체",
    "additionalExamples": [
      {
        "title": "중첩 컨텍스트 매니저",
        "code": "# 여러 컨텍스트 매니저 동시 사용\nfrom contextlib import ExitStack\n\n# ExitStack을 사용한 동적 컨텍스트 관리\nwith ExitStack() as stack:\n    # 여러 파일을 동시에 열기\n    files = []\n    for i in range(3):\n        try:\n            f = stack.enter_context(open(f'file{i}.txt', 'w'))\n            files.append(f)\n        except Exception as e:\n            print(f\"파일 {i} 열기 실패: {e}\")\n    \n    # 모든 파일에 쓰기\n    for i, f in enumerate(files):\n        f.write(f\"파일 {i} 내용\\n\")\n    \n    print(f\"{len(files)}개 파일 처리 완료\")\n# 모든 파일이 자동으로 닫힘\n\n# suppress를 사용한 예외 무시\nfrom contextlib import suppress\n\nwith suppress(FileNotFoundError):\n    with open('nonexistent.txt', 'r') as f:\n        content = f.read()\nprint(\"파일이 없어도 계속 실행됨\")"
      }
    ],
    "categoryId": 8,
    "order": 3,
    "prevSlug": "decorators",
    "nextSlug": "async-await"
  }
]